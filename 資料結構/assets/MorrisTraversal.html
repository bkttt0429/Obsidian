import React, { useState, useEffect, useMemo } from 'react';
import { Play, Pause, SkipForward, RotateCcw, Info, CheckCircle2 } from 'lucide-react';

// 定義初始樹結構
const INITIAL_TREE = {
  id: '1',
  val: 1,
  left: {
    id: '2',
    val: 2,
    left: { id: '4', val: 4, left: null, right: null },
    right: { id: '5', val: 5, left: null, right: null }
  },
  right: {
    id: '3',
    val: 3,
    left: null,
    right: { id: '6', val: 6, left: null, right: null }
  }
};

const App = () => {
  const [currentId, setCurrentId] = useState(null);
  const [predecessorId, setPredecessorId] = useState(null);
  const [threads, setThreads] = useState([]);
  const [traversalResult, setTraversalResult] = useState([]);
  const [logs, setLogs] = useState([]);
  const [isPlaying, setIsPlaying] = useState(false);
  const [stepIndex, setStepIndex] = useState(-1);

  // 預先計算演算法的所有步驟快照
  const steps = useMemo(() => {
    const s = [];
    const res = [];
    let curThreads = [];
    
    const findNodeById = (root, id) => {
      if (!root) return null;
      if (root.id === id) return root;
      return findNodeById(root.left, id) || findNodeById(root.right, id);
    };

    const getRight = (node, tList) => {
      const thread = tList.find(t => t.from === node.id);
      if (thread) return findNodeById(INITIAL_TREE, thread.to);
      return node.right;
    };

    let curr = INITIAL_TREE;
    while (curr !== null) {
      s.push({
        type: 'CHECK',
        curr: curr.id,
        pre: null,
        threads: [...curThreads],
        res: [...res],
        msg: `當前節點是 ${curr.val}。檢查是否有左子樹。`
      });

      if (curr.left === null) {
        res.push(curr.val);
        s.push({
          type: 'VISIT',
          curr: curr.id,
          pre: null,
          threads: [...curThreads],
          res: [...res],
          msg: `${curr.val} 沒有左子樹。訪問該節點，並移至右子樹。`
        });
        curr = getRight(curr, curThreads);
      } else {
        let pre = curr.left;
        s.push({
          type: 'FIND_PRE',
          curr: curr.id,
          pre: pre.id,
          threads: [...curThreads],
          res: [...res],
          msg: `尋找 ${curr.val} 的前驅節點（左子樹的最右節點）。`
        });

        while (getRight(pre, curThreads) !== null && getRight(pre, curThreads).id !== curr.id) {
          pre = getRight(pre, curThreads);
        }

        if (getRight(pre, curThreads) === null) {
          curThreads.push({ from: pre.id, to: curr.id });
          s.push({
            type: 'ADD_THREAD',
            curr: curr.id,
            pre: pre.id,
            threads: [...curThreads],
            res: [...res],
            msg: `前驅節點 ${pre.val} 的右指針為空。建立線索指向 ${curr.val}，進入左子樹。`
          });
          curr = curr.left;
        } else {
          curThreads = curThreads.filter(t => !(t.from === pre.id && t.to === curr.id));
          res.push(curr.val);
          s.push({
            type: 'REMOVE_THREAD',
            curr: curr.id,
            pre: pre.id,
            threads: [...curThreads],
            res: [...res],
            msg: `前驅節點 ${pre.val} 已有線索。斷開線索，訪問 ${curr.val}，並移至右子樹。`
          });
          curr = getRight(curr, curThreads);
        }
      }
    }
    s.push({ type: 'DONE', curr: null, pre: null, threads: [], res: [...res], msg: "遍歷完成！" });
    return s;
  }, []);

  useEffect(() => {
    let timer;
    if (isPlaying && stepIndex < steps.length - 1) {
      timer = setTimeout(() => {
        handleNext();
      }, 1000);
    } else {
      setIsPlaying(false);
    }
    return () => clearTimeout(timer);
  }, [isPlaying, stepIndex]);

  const handleNext = () => {
    if (stepIndex < steps.length - 1) {
      const nextIdx = stepIndex + 1;
      const step = steps[nextIdx];
      setStepIndex(nextIdx);
      setCurrentId(step.curr);
      setPredecessorId(step.pre);
      setThreads(step.threads);
      setTraversalResult(step.res);
      setLogs(prev => [step.msg, ...prev].slice(0, 5));
    }
  };

  const handleReset = () => {
    setStepIndex(-1);
    setCurrentId(null);
    setPredecessorId(null);
    setThreads([]);
    setTraversalResult([]);
    setLogs([]);
    setIsPlaying(false);
  };

  // 計算節點位置
  const nodePositions = useMemo(() => {
    const pos = {};
    const calculate = (node, x, y, dx) => {
      if (!node) return;
      pos[node.id] = { x, y, val: node.val };
      calculate(node.left, x - dx, y + 60, dx / 1.7);
      calculate(node.right, x + dx, y + 60, dx / 1.7);
    };
    calculate(INITIAL_TREE, 200, 40, 100);
    return pos;
  }, []);

  return (
    <div className="flex flex-col h-full bg-neutral-50 p-6 font-sans text-neutral-800 rounded-xl border border-neutral-200 shadow-sm">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold text-neutral-900">Morris Traversal 視覺化</h1>
          <p className="text-neutral-500 text-sm">空間複雜度 $O(1)$ 的中序遍歷模擬</p>
        </div>
        <div className="flex space-x-2">
          <button
            onClick={() => setIsPlaying(!isPlaying)}
            className={`flex items-center space-x-2 px-4 py-2 rounded-lg transition ${isPlaying ? 'bg-amber-500 text-white' : 'bg-blue-600 text-white hover:bg-blue-700'}`}
          >
            {isPlaying ? <Pause size={18} /> : <Play size={18} />}
            <span>{isPlaying ? '暫停' : '自動播放'}</span>
          </button>
          <button
            onClick={handleNext}
            disabled={isPlaying || stepIndex >= steps.length - 1}
            className="flex items-center space-x-2 px-4 py-2 bg-neutral-200 text-neutral-700 rounded-lg hover:bg-neutral-300 disabled:opacity-50"
          >
            <SkipForward size={18} />
            <span>下一步</span>
          </button>
          <button
            onClick={handleReset}
            className="flex items-center space-x-2 px-4 py-2 border border-neutral-300 rounded-lg hover:bg-white transition"
          >
            <RotateCcw size={18} />
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 flex-1">
        {/* 左側：樹圖形區域 */}
        <div className="lg:col-span-2 bg-white rounded-xl border border-neutral-200 p-4 flex flex-col items-center justify-center relative overflow-hidden">
          <svg width="400" height="300" viewBox="0 0 400 300" className="drop-shadow-sm">
            {/* 繪製線條 */}
            {Object.entries(INITIAL_TREE).map(() => {
              const drawLines = (node) => {
                if (!node) return null;
                const lines = [];
                if (node.left) {
                  const p1 = nodePositions[node.id];
                  const p2 = nodePositions[node.left.id];
                  lines.push(<line key={`l-${node.id}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#e5e5e5" strokeWidth="2" />);
                }
                if (node.right) {
                  const p1 = nodePositions[node.id];
                  const p2 = nodePositions[node.right.id];
                  lines.push(<line key={`r-${node.id}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#e5e5e5" strokeWidth="2" />);
                }
                return [...lines, drawLines(node.left), drawLines(node.right)];
              };
              return drawLines(INITIAL_TREE);
            })}

            {/* 繪製線索 Threads */}
            {threads.map((t, i) => {
              const start = nodePositions[t.from];
              const end = nodePositions[t.to];
              const cx = Math.max(start.x, end.x) + 40;
              const cy = (start.y + end.y) / 2;
              return (
                <path
                  key={`thread-${i}`}
                  d={`M ${start.x} ${start.y} Q ${cx} ${cy} ${end.x} ${end.y}`}
                  fill="none"
                  stroke="#10b981"
                  strokeWidth="2"
                  strokeDasharray="4"
                  className="animate-pulse"
                />
              );
            })}

            {/* 繪製節點 */}
            {Object.values(nodePositions).map((pos) => {
              const isCurr = currentId === Object.keys(nodePositions).find(key => nodePositions[key] === pos);
              const isPre = predecessorId === Object.keys(nodePositions).find(key => nodePositions[key] === pos);
              return (
                <g key={pos.val}>
                  <circle
                    cx={pos.x}
                    cy={pos.y}
                    r="18"
                    className="transition-all duration-500"
                    fill={isCurr ? '#3b82f6' : isPre ? '#f59e0b' : '#fff'}
                    stroke={isCurr ? '#2563eb' : isPre ? '#d97706' : '#d4d4d4'}
                    strokeWidth="2"
                  />
                  <text
                    x={pos.x}
                    y={pos.y}
                    dy="5"
                    textAnchor="middle"
                    className={`text-xs font-bold transition-colors ${isCurr || isPre ? 'fill-white' : 'fill-neutral-600'}`}
                  >
                    {pos.val}
                  </text>
                </g>
              );
            })}
          </svg>
          
          <div className="absolute bottom-4 left-4 flex flex-col space-y-1">
            <div className="flex items-center space-x-2 text-[10px] text-neutral-500">
              <div className="w-3 h-3 bg-blue-500 rounded-full" /> <span>當前節點 (Current)</span>
            </div>
            <div className="flex items-center space-x-2 text-[10px] text-neutral-500">
              <div className="w-3 h-3 bg-amber-500 rounded-full" /> <span>前驅節點 (Predecessor)</span>
            </div>
            <div className="flex items-center space-x-2 text-[10px] text-neutral-500">
              <div className="w-3 h-1 bg-green-500 border-t border-dashed" /> <span>臨時線索 (Thread)</span>
            </div>
          </div>
        </div>

        {/* 右側：狀態與日誌 */}
        <div className="flex flex-col space-y-4">
          <div className="bg-neutral-900 rounded-xl p-4 shadow-lg min-h-[160px]">
            <h3 className="text-neutral-400 text-xs font-mono mb-2 uppercase tracking-wider">執行日誌 (Logs)</h3>
            <div className="space-y-2">
              {logs.length > 0 ? (
                logs.map((log, i) => (
                  <div key={i} className={`text-sm font-mono leading-tight ${i === 0 ? 'text-green-400' : 'text-neutral-500'}`}>
                    {i === 0 ? '> ' : '  '}{log}
                  </div>
                ))
              ) : (
                <div className="text-neutral-600 italic text-sm font-mono">等待開始...</div>
              )}
            </div>
          </div>

          <div className="bg-white rounded-xl border border-neutral-200 p-4 flex-1">
            <h3 className="flex items-center space-x-2 text-sm font-bold mb-4">
              <CheckCircle2 size={16} className="text-green-500" />
              <span>中序遍歷結果 (Result)</span>
            </h3>
            <div className="flex flex-wrap gap-2">
              {traversalResult.length > 0 ? (
                traversalResult.map((v, i) => (
                  <span key={i} className="px-3 py-1 bg-green-50 text-green-700 rounded-md font-mono font-bold animate-in fade-in zoom-in">
                    {v}
                  </span>
                ))
              ) : (
                <span className="text-neutral-300 italic text-xs">暫無輸出</span>
              )}
            </div>
          </div>
        </div>
      </div>
      
      <div className="mt-6 flex items-start space-x-3 p-4 bg-blue-50 border border-blue-100 rounded-lg">
        <Info size={20} className="text-blue-500 mt-1" />
        <div className="text-xs text-blue-800 leading-relaxed">
          <p className="font-bold mb-1">Morris Traversal 核心原理：</p>
          當我們遍歷到左子樹的最右節點時，發現它的右指針為空。這就是「浪費」的空間。我們將它暫時指向當前節點，這樣遍歷完左子樹後，我們就能順著這個「線索」回到父節點，而不需要使用棧。
        </div>
      </div>
    </div>
  );
};

export default App;