# 內存管理

上次編輯時間: 2025年12月16日 下午4:46
建立時間: 2025年9月1日 下午5:21

![image.png](assets/image%208.png)

# 零、內存基本功能

## 1) 内存/存储单元/地址

- **内存作用**：CPU 运行前把程序与数据先放入内存，以缓冲 CPU 与外存速度差。
- **存储单元**：最小存储单位；计算机可**按字节编址**（1 地址=1 Byte=8 bits），也可能**按字编址**（1 地址=1 字，字长 16/32/64…bit，题目给定）。
- **地址编号**：从 0 递增，每个地址对应一个存储单元。
- **地址位数**：若按字节编址、内存=4 GB ⇒ 单元数=2^32 ⇒ **地址需要 32 位**。

## 2) 指令执行的本质

- **机器指令=操作码 + 若干参数**（常含地址或寄存器编号）。
- CPU 执行过程就是**按地址取/写数据 + 运算**（示例：把 x 读到寄存器→加 1→写回内存）。

## 3) 逻辑地址 vs 物理地址

- **逻辑地址（相对地址）**：编译/链接生成的指令中使用的地址，**相对于程序起始位置**。
- **物理地址**：内存中的真实地址。
- 问题：程序装入内存的**起始位置不确定**，需把逻辑地址→物理地址。

## 4) 逻辑→物理 的三种装入/重定位策略（核心考点）

1. **绝对装入**
    - 事先就知道要从哪儿装入；编译阶段直接写成**绝对物理地址**。
    - 灵活性差，仅适合早期单道环境。
2. **可重定位装入（静态重定位）**
    - 装入时一次性把所有与地址相关的项**统一加上起始物理地址**（如 +100）。
    - 要求**连续内存，整段一次装入**；运行期间**不可移动**。
3. **动态重定位（运行时装入）**
    - 指令中始终用**逻辑地址**；CPU 访问时由**重定位寄存器（base）与逻辑地址相加**得到物理地址。
    - 优点：可移动、可不连续分配、可部分装入、便于共享，支撑后续**虚拟存储**思想。

> 记忆：静态装入时改“指令中的地址”；动态装入时改“访问时的地址”（用 base+offset）。
> 

## 5) 从源码到运行：四步总览

1. **编写**：.c 等源文件。
2. **编译**：每个源文件→**目标模块**（.o），各模块各自从逻辑地址 0 开始。
3. **链接**：把多个目标模块+库函数**组装**成**装入模块（可执行文件，EXE）**，得到**完整的逻辑地址空间**。
4. **装入**：把装入模块放入内存，完成**逻辑→物理**地址映射（用上述 3 种策略之一）。

## 6) 三种**链接**方式（区分于“装入”）

- **静态链接**：运行前把所有模块先连成一个**完整可执行文件**（逻辑地址一次性确定）。
- **装入时动态链接**：装入到内存时再链接；**边装入边形成**进程的完整逻辑地址。
- **运行时动态链接**：**用到哪个再装入并链接**（如调用到某函数时才加载对应模块），更省内存、更灵活。

## 7) 高频考点速背

- **地址位数**：单元数=地址空间大小/编址单位；位数=log₂(单元数)。
- **B/b 区分**，KB/MB/GB = 2 的幂。
- **装入 vs 链接**：**链接确定“完整逻辑地址”**；**装入确定“物理地址”**。
- **动态重定位**关键词：**重定位寄存器、base+offset、可移动/不连续/部分装入**。

## 1.內存映射

# 进程的内存印象（32 位)

## 总览（虚拟地址 4 GB）

![image.png](assets/image%209.png)

- **内核空间（高 1 GB，约 0xC0000000–0xFFFFFFFF）**：内核代码/数据、进程 PCB、页表…用户态不可直接访问。
- **用户空间（低 3 GB）**：从低到高大致分区：
    1. **未用/保留区**（极低地址）
    2. **代码/只读区**：`.text` 机器指令（只读执行） + **只读数据**（如 `const`、字符串常量）（只读）。
    3. **可读写数据区**：全局变量、**static** 变量（读写，进程整个生命周期存在）。
    4. **堆（heap）**：`malloc/free` 管理，**向高地址增长**；在常见 32 位布局中，堆最高大致到 **0x40000000** 左右（即“4 + 7 个 0”），受下方区域大小与中间映射区挤压。
    5. **共享库/映射区（mmap 区）**：动态链接库代码等（如 `printf` 所在的 libc）。
    6. **用户栈（stack）**：函数调用栈帧、返回地址、参数、**非 static 局部变量**，**向低地址增长**。

> 口诀：代码只读、数据可写、堆上长、栈下长、库在中、内核高。
> 

## 变量放哪儿？（结合 C 关键点）

- `const` 修饰的**常变量** → **只读区**（随程序不可改）。
- **宏 `#define` 常量** → **不占独立内存**；预处理直接替换为字面值，常作为**立即数**嵌入指令。
- **全局变量** / **static 变量（含函数内 static）** → **可读写数据区**（进程期常驻）。
- **局部变量（非 static）** → **栈**（随调用创建/销毁）。
- `malloc/new` 得到的对象 → **堆**（手动管理，失败多因堆被映射区/栈“夹住”或地址空间不足）。
- 库函数代码（如 `printf`）→ **共享库/映射区**。

## 考点速查 & 小题库

- **判断位置**按三维：**可写性**（只读/读写）＋**生命周期**（瞬时/进程期/手动）＋**获取方式**（自动/静态/动态分配）。
- 选择题常问：“某变量/常量存放在哪个区？”
    - `static` 影响**存储期**（进程期），不等于“放栈/堆”。
    - 宏常量：**不进只读段**；`const` 常变量：**进只读段**。
- 计算/实验题：32 位进程可 `malloc` 的上限≈受**代码+只读+数据**（低端 1 GB 范围内）大小 + **中间映射区** + **栈**共同限制；堆典型上界约 **0x40000000**。

## **2.內存管理基本概念**

## 1) 内存管理要做的四件事

1. **分配与回收**
    - 维护“已分配/空闲”内存；当进程创建时**放哪儿**，结束时**怎么回收**。
    - 具体算法与数据结构（如连续分配/分页/分段、空闲表/空闲链表等）放在后续小节。
2. **内存扩充（虚拟性）**
    - 让“物理内存小”也能运行“逻辑上很大”的程序（如 60GB 游戏在 4GB 内存上）。
    - 通过把一部分不常用内容放到外存，实现“看起来更大的内存空间”（虚拟存储）。
3. **地址转换（重定位）**
    - 程序员只关心**逻辑地址**；OS 负责把逻辑地址→**物理地址**。
    - 三种装入/重定位方式（见下）。
4. **存储保护**
    - **只许访问自己的空间**：用户进程不得越界，也不能读写内核或其他进程空间。

## 2) 三种装入 / 重定位方式（地址转换）

- **绝对装入**（单道、无 OS 时代）
    
    在**编译期**就产出绝对物理地址；换机器/起始位不同会失效。
    
- **可重定位装入 = 静态重定位**（早期多道批处理）
    
    **装入时**一次性把逻辑地址整体**加起始物理址**（base）；要求**连续、整段装入**，**运行期不可移动**。
    
- **动态运行时装入 = 动态重定位**（现代系统主流）
    
    指令中一直用**逻辑地址**；CPU 访问时用
    
    **物理地址 = 重定位寄存器（Base） + 逻辑地址（offset）**。
    
    优点：可移动、不连续、可部分装入，支撑虚拟内存/共享等。
    

## 3) 存储保护的两种典型做法

- **上下限寄存器（下限/上限）**
    
    访问合法当且仅当：`lower ≤ 目标物理地址 ≤ upper`。
    
- **重定位寄存器 + 界地址寄存器**（= 基址 + 限长）
    
    先判越界：`offset ≤ limit`；再做转换：`phys = base + offset`。
    
    - 名词对照：**重定位寄存器=基址寄存器**，**界地址寄存器=限长寄存器**。

# 一、內存空間分配與回收

---

## 1.连续分配管理

**1⃣ 概念总览**

- **连续分配**：给进程分配**一整块连续**物理内存（对比：非连续分配=离散块）。
    - 三种方式：
        - **单一连续分配**
        - **固定分区**
        - **动态分区（可变分区）**。

**考点速背**

- **碎片相关**
    - **内部碎片**：分到手但**未被进程使用**的那部分（固定/单一方式高发）。
    - **外部碎片**：内存里有很多**零碎空闲块**，合计足够但**单块都不够大**。
    - **紧凑（Compaction）**：搬家挪位，把分散空闲**拼成大块**（需**动态重定位**支持；修改 PCB 中基址/起始地址，装入时写入**重定位寄存器**）。
- **是否产生外/内部碎片**
    - 单一连续：**无外部**，**有内部**。
    - 固定分区：**无外部**，**有内部**（整分区独占）。
    - 动态分区：**无内部**（恰配），但**易有外部**（需紧凑）。
- **分区表/链**：知道字段（起始地址、大小、状态/指针），会分析回收**四种**合并场景。
- **紧凑适用前提**：支持**动态重定位**；回写新的起始地址到**PCB → 重定位寄存器**。
- **固定分区不等大**：按作业大小分布设计大/中/小分区数量。
- **等大分区场景**：大量**相同对象**的并行控制程序。

---

### 1.1.单一连续分配

![image.png](assets/image%2010.png)

- **布局**：内存=系统区（OS）+ 用户区（仅**一道**用户程序独占）。
- **特点**
    - ✅ 实现简单；**无外部碎片**；（很多早期系统）**可不做**内存保护。
    - ❌ 仅**单用户单任务**；**内部碎片**明显（用户区未用部分被浪费）；内存利用率低。

---

### 1.2.固定分区分配

![image.png](assets/image%2011.png)

- **做法**：用户区预先切成若干**固定大小**分区，每分区**只装一道作业**。
- **两种形态**
    - 分区**等大**：实现简单但**灵活性差**；小作业浪费，大作业可能进不来（需覆盖）。
    - 分区**不等大**：按“大/中/小”作业比例设置若干大中小分区，更灵活。
- **管理**：建立**分区说明表**（起始地址、大小、是否已分配）。
- **优缺点**
    - ✅ 管理简单，**无外部碎片**。
    - ❌ **内部碎片**不可避免；大作业可能需**覆盖技术**；弹性差。
- **应用举例**：N 个相同控制对象（如炼钢炉），放 N 份相同控制程序到 N 个等大分区并发控制。

---

### 1.3.动态分区分配

![image.png](assets/image%2012.png)

- **做法**：**按需**在装入时为进程**动态建立**恰好大小的分区；分区**大小/数量可变**。
- **要解决三件事**
    1. **如何记录空闲块**
        - **空闲分区表**（每块一表项：起始地址、大小…）
        - **空闲分区链**（空闲块做成链表，块头/尾含前后指针与元数据）
    2. **从多个可用空闲块中选哪一块**（= 分配算法：下一节详讲，如首次适应、最佳适应等）
    3. **如何分配与回收并合并**
        - **分配**
            - 若“选中块 > 需求”：**切分**并更新该表项（起始地址/大小）。
            - 若“选中块 == 需求”：**整块分配**并**删除**该表项/节点。
        - **回收（四种情况，抓住本质）**
            - 与**右邻**空闲相邻 → 合并更新
            - 与**左邻**空闲相邻 → 合并更新
            - 与**左右**皆空闲 → **三块合一**
            - **左右皆不空** → 新增一表项/节点
                
                👉 **口诀：相邻就合并，能并全并。**
                

---

### 1.4.动态分区分配算法

## 常用数据结构

- **空闲分区表 / 空闲分区链**
    
    表项/节点需含：起始地址、大小（必要时还含前后指针）。
    
- **回收必做**：与左/右相邻空闲块**能并就并**（左并、右并、左右并、都不邻则新建表项）。

## 四大算法（按考试常见顺序）

> 说明：你稿子里“最快适应”应为最坏/最大适应（Worst/Largest-Fit）。
> 

| 算法 | 排序/维护 | 选择规则 | 优点 | 典型缺点 | 备注 |
| --- | --- | --- | --- | --- | --- |
| **首次适应 FF** | **按地址递增**；无需重排 | 从低址开始找**第一个**可用块 | 实现/维护**最省**；查找开销小 | 低地址易留下许多小碎片 | 隐含“保留高地址大块”的倾向 |
| **最佳适应 BF** | **按大小递增**；常需重排 | 选**最小够用**的块 | 尽量保留大块 | **小碎片最多**；维护成本高 | 易频繁重排/重插 |
| **最坏/最大适应 WF** | **按大小递减**；常需重排 | 选**最大**的块 | 直接避免很小残块 | **大块被切碎**，后续大作业难放；维护成本高 | 也叫 Largest-Fit |
| **邻近适应 NF** | **按地址递增**的**循环链**；无需重排 | **从上次结束处**继续找 | 避免每次都从低址扫；平均查找步数常比 FF 少 | 更可能动到高址大块，**保大块能力差于 FF** | 指针位置是判分点！ |

### 小结口诀

- **FF**：第一个合适，**低址碎**；大块尚能留。
- **BF**：最小够用，**小碎最多**；保大块但维护贵。
- **WF**：用最大块，**大块被锯**；后面大作业难。
- **NF**：接着上次找，**扫得快**；高址大块更易被用。

## 分配与回收操作（面试/大题常考）

- **分配**
    - `选中块 > 需求`：切分、更新剩余块的大小/起址；是否重排取决于算法（BF/WF 常需）。
    - `选中块 == 需求`：整块分配并**删除**该空闲项/节点。
- **回收**
    - 与左/右/左右相邻即**合并**，更新表项；BF/WF 可能因大小变化触发重排。

## 碎片与紧凑

- **内部碎片**：给了进程但**没用上**的部分（固定/单一方式高发）。
- **外部碎片**：很多小空闲块**凑不成**所需的大连续块（**动态分区**高发）。
- **紧凑（Compaction）**：搬家挤成大块；需**动态重定位**支持（修改 PCB 中基址/起始地址→装入重定位寄存器）。

## 选择建议 & 考点提醒

- **综合表现**：考试与实务里，**FF 通常最均衡**；**BF**保大块但碎片多且维护重；**WF**不利大作业；**NF**查找快但保大块能力弱于 FF。
- **判题关键**：
    1. 看链的**排序规则**是否被你维护对（FF/NF 按地址；BF 递增；WF 递减）。
    2. **NF 起始指针**从**上次结束位置**算起（循环）。
    3. 分配后**是否要重排**（BF/WF 多见）。
    4. 回收时**相邻即合并**。

## 2.非連續分配

---

- 基本地址变换机构
    
    ## 关键硬件
    
    - **页表寄存器（PTR）**：保存**页表起始地址**（基址）和**页表长度 m**（表项个数）。
        - 进程被调度时，内核把这俩从 PCB 恢复到 PTR。
    
    ## 逻辑→物理地址的四步（必背流程）
    
    1. **拆分逻辑地址 A → 页号 p、页内偏移 w**
        - 若页长 `L=2^k`：后 k 位是 w，前面是 p。
        - 否则：`p = A // L`，`w = A % L`。
    2. **越界检查**：`p ≥ m` ⇒ 越界中断（注意取等也越界；编号从 0 开始）。
    3. **取页表项**：`PTE_addr = PTBR + p * PTE_size`，读出**页框号 f**。
        - 页号**隐含**，PTE 里最基本只需存页框号。
    4. **形成物理地址**：
        - 若 `L=2^k`：`PA = (f << k) | w`（拼接/左移）。
        - 否则：`PA = f * L + w`。
    
    > 性能点：一次访存要查页表 1 次 + 访问目标单元 1 次 = 2 次访存。
    > 
    > 
    > 下节用快表（TLB）优化这里的第一下。
    > 
    
    ## 易混概念对齐
    
    - **页表长度 m**：页表项**个数**（= 进程页面数）。
    - **页表项长度 PTE_size**：每项占**多少字节**（存页框号及标志）。
    - **页面大小 L**：每页/每页框字节数。
    - **页号不占存储空间**（隐含，因为 PTE 连续存放）。
    
    ## PTE 至少几字节？（常考）
    
    - 物理内存 M、页长 L ⇒ 页框数 `F = M / L` ⇒ 页框号需 `⌈log2 F⌉` 位 ⇒
        
        **`PTE_min_bytes = ⌈⌈log2 F⌉ / 8⌉`**。
        
    - 例：内存 4GB，页 4KB ⇒ `F=2^(32-12)=2^20` ⇒ 20 位 ⇒ **≥3B**。
        
        实务常取 **4B/8B**（整页装**整数个**PTE，避免“页内碎片”的对齐麻烦）。
        
    
    ## 一维地址的含义（选择题常见）
    
    - 分页系统的地址**一维**：给 CPU **一个**“逻辑地址 A”就够了；页号、偏移由硬件按既定格式拆。
    
    ## 典型计算题模板
    
    > 已知：按字节寻址；页长 L=1KB(=2^10)；页号 2 → 页框号 f=8；逻辑地址 A=2500。
    > 
    > 
    > 解：`p = 2500 // 1024 = 2`，`w = 2500 % 1024 = 452`；
    > 
    > `PA = (8 << 10) + 452 = 8192 + 452 = 8644`。
    > 
    
    ## 容易丢分的点
    
    - 忘记**越界检查**（`p ≥ m` 触发异常）。
    - 把**页框号**误当成**物理起址**（需 ×L 或 `<<k`）。
    - **从 0 编号**。
    - PTE 最小位数算完**还要向字节取整**。
    - 分清 **m / PTE_size / L** 三者含义。
    
    ---
    

### 2.1.基本分页

## 核心概念（别混）

- **页（page/页面）**：进程**逻辑地址空间**被等块划分的单位。
- **页框（page frame/页帧/内存块/物理页）**：**物理内存**被等块划分的单位。
- **一一对应**：页 ↔ 页框（离散装入）。页大小 = 页框大小。
- **同义词提醒**：页框号=页帧号=内存块号=物理页号（从 0 编号）。

## 页表（每进程一张）

- 存放处：通常在 **PCB** 中有其描述/指针；**页表项(PTE)** 在内存中**连续**、等长存放。
- **最简 PTE 内容**：仅“**页框号**”（考试本节一般不引入有效位/保护位等）。
- **页号不占空间**：因表项连续存放，`第 i 项地址 = 页表起址 + i * PTE_长度`。

![image.png](assets/image%2013.png)

### 计算：PTE 至少几字节？

1. 设物理内存大小 `M`，页大小 `P`（字节）。
2. 页框总数 `F = M / P`。
3. 表示页框号至少需 `⌈log2(F)⌉` 位 → **按字节向上取整**：`PTE_最少字节 = ⌈⌈log2(F)⌉ / 8⌉`。

> 例：内存 4GB、页 4KB ⇒ F=2^(32-12)=2^(20) ⇒ 需 20 位 ⇒ 至少 3 字节/项。
> 
> 
> 若页表有 `(n+1)` 项（页号 0…n），纯存页框号共需 `3*(n+1)` 字节。
> 

## 逻辑地址结构（页号 + 页内偏移）

- 若页大小 `P = 2^k`：
    - **偏移**占 `k` 位（页内地址 `0…2^k-1`）；
    - 假设逻辑地址共 `m+k` 位，则**页号**占 `m` 位，进程**最多** `2^m` 页。
- 若页大小**不是** 2 的幂：页号=“逻辑地址 ÷ P（取整）”，偏移=“逻辑地址 mod P”。

## 地址变换流程（必背）

1. 逻辑地址 → **页号 p、偏移 w**。
2. 查页表：得 **页框号 f**。
3. 物理地址 = **页框起址 + w**。
    - 若 `P=2^k`：**起址 = f << k**，可直接**拼接**：
        
        `物理地址 = (f << k) | w`（无需乘法/取余，硬件更快）。
        
    - 否则需做乘法：`起址 = f * P`，再 `+ w`。

### 小例子（4KB 页，32 位地址）

- `k=12`，页框数 `2^(32-12)=2^20`，PTE≥3B。
- 逻辑地址 `4097`：`p = 1`，`w = 1`。若 `页表[1]=9` ⇒
    
    物理地址 `= (9 << 12) + 1 = 9*4096 + 1 = 36865`。
    

## 易错点｜判分锚

- **术语**：页（逻辑）≠ 页框（物理）。
- **页表项记录的是“页框号”，不是起始物理地址**。起址需 `页框号 × 页大小`（或左移 `k` 位）。
- **页号隐含**，不单独占存储空间。
- **页大小为 2^k 的两大好处**：
    1. 拆分地址只需“按位切割”（前 m 位页号，后 k 位偏移）；
    2. 物理地址计算可用**左移/拼接**，无需乘除取余。
- **编号从 0 开始**（页框号/页号）。
- 计算 `⌈log2(·)⌉` 后记得**按字节再向上取整**。

---

---

### **TLB**

# 1. 核心概念

- **TLB（快表, Translation Lookaside Buffer）TLB 作為一個高度專業化、專用的位址轉譯快取，是繞過這種固有延遲的架構性要求**，確保絕大多數記憶體操作能在幾個時脈週期內完成

：放“**最近访问**的页表项副本”的**硬件缓存**，访问速度 ≫ 内存。
    - TLB ≠ 内存；TLB 中是 **PTE 副本**，而不是一般数据。
- **慢表**：放在内存中的**整张页表**。
- **为什么快**：命中时**不用查慢表**，直接给出物理块号，地址变换只花 TLB 时间。
- **上下文切换**：进程切换时通常**清空 TLB。**

**TLB 的分類** 

---

TLB 通常根據它們處理的記憶體存取類型進行分類：

- **指令 TLB (ITLB)：** 快取用於獲取指令的轉譯。
- **資料 TLB (DTLB)：** 快取用於資料載入/儲存操作的轉譯。
- **統一 TLB (UTLB)：** 許多架構還包含統一 TLB，作為較大的次級（L2）轉譯快取，用於處理 L1 TLB 遺漏的指令和資料轉譯請求

---

**對於資料區的輔助資訊包括以下內容：**

![image.png](assets/image%2014.png)

1. 有效位元(Valid)：對於作業系統，所有的資料都不會載入進內存，當資料不在記憶體的時候，就需要到硬碟尋找並載入到記憶體。當為1時，表示在內存上，為0時，該頁不在內存，就需要到硬碟查找。
2. 引用位(reference):由於TLB中的項數是一定的，所以當有新的TLB項需要進來但是又滿了的話，如果根據LRU演算法，就將最近最少使用的項替換成新的項。故需要引用位。同時要注意的是，頁表中也有引用位。
3. 髒位(dirty):當記憶體上的某個區塊需要被新的區塊替換時，它需要根據髒位判斷這個區塊之前有沒有被修改過，如果被修改過，先把這個區塊更新到硬碟再替換，否則就直接替換。

---

# 2. 含 TLB 的地址变换流程

1. 逻辑地址拆分：`页号 p` + `页内偏移 d` → 越界检查（页表长度）。
2. **查 TLB**：
    - **命中**：取出 **物理块号 f**，构成物理地址 `(f, d)`，**访问内存一次**取数/取指。
    - **未命中**：去**慢表**查到 PTE（并**回填 TLB**，若满则替换），再用 `(f, d)` 访问目标内存。
    
    ![image.png](assets/image%2015.png)
    
3. **局部性原理**支撑高命中（常见>90%）：
    
    ![image.png](assets/image%2016.png)
    
    - **时间局部性**：刚用过的代码/数据很快还会用。
    - **空间局部性**：用过的附近地址很快会用。

---

# 3. 平均访存时间（EAT/AAT）公式（做题模板）

设：

- `t_TLB`=TLB 查找时间（例 1 μs），`t_M`=内存一次访问时间（例 100 μs）
- `h`=TLB 命中率

## 串行查找（先 TLB，未命中再查慢表）

- **命中**：`t_TLB + t_M`
- **未命中**：`t_TLB + t_M(查慢表) + t_M(取目标)`
- **EAT**：`h·(t_TLB + t_M) + (1-h)·(t_TLB + 2·t_M)`

> 例：t_TLB=1，t_M=100，h=0.9
> 
> 
> `EAT = 0.9·(1+100) + 0.1·(1+200) = 111 μs`
> 
> **无 TLB**时：每次都要“查慢表+取目标”=`2·t_M=200 μs`
> 

## 同时查找（TLB 与慢表并行启动）

- **命中**：仍是 `t_TLB + t_M`（1 μs 得到块号后再取数 100 μs）
- **未命中**：慢表已并行查了 `t_TLB`，总体≈`t_M(查慢表) + t_M(取目标)`（若 `t_M≫t_TLB`）
- **EAT**：`h·(t_TLB + t_M) + (1-h)·(t_M + t_M)`

> 例：0.9·101 + 0.1·200 = 110.9 μs（比串行 miss 少 1 μs）
> 

> 判题小心：「是否并行查找」通常明示；并行时miss 情况不再额外加 t_TLB。
> 

---

# 4. 命中与访存次数速记

- **命中**：地址变换不用慢表 → **仅 1 次内存访问**（取指/取数）。
- **未命中**：**2 次内存访问**（查慢表一次 + 取目标一次）。
- 查 TLB 本身**不算内存访问**（它是独立硬件缓存）。

---

# 5. TLB 与 Cache 的区别

- **TLB** 存 **页表项（虚实映射）**；
- **Cache** 存 **普通数据/指令块的副本**；
- 作用层次不同：TLB 用于**地址翻译**，Cache 用于**访存加速**（拿到物理地址之后）。

---

# 6. 典型考点/易错

- **越界检查**：页号先与“页表长度”比对。
- **TLB 命中时是否还访慢表？**—不需要。
- **并行/串行**别混：并行 miss 不再加 `t_TLB`；串行 miss 要 `t_TLB + 2·t_M`。
- **别忘了回填 TLB** 与“TLB 满则替换”的表述（策略常见：LRU/随机，题目一般不深挖）。
- **题目口径**：有的只问“地址变换开销”，有的问“访问一个逻辑地址的总耗时”（含最终取数）——按题意代入。

---

# 7. 一屏速背

- 公式（串行）：`EAT = h·(t_TLB + t_M) + (1-h)·(t_TLB + 2·t_M)`
- 公式（并行）：`EAT = h·(t_TLB + t_M) + (1-h)·(2·t_M)`
- 命中 1 次访存；未命中 2 次访存；TLB 清空在进程切换；TLB≠Cache。

- **两级页表**
    
    # 1) 单级页表的两大问题
    
    - **页表必须连续存放**：页表很大时要占用大量**连续**页框，违背离散分配的初衷。
    - **整张常驻内存浪费**：局部性决定进程一段时间只用到**少数页面**，没必要让整张页表在内存里。
    
    # 2) 两级页表的思路与结构
    
    - 把“长页表”按“**一页能装下的PTE数**”切成多个**二级页表**；再用**页目录表（外层/顶层页表）**记录“**二级页表号 → 所在物理块号**”。
    - 逻辑地址三段式：`[一级页号 p1 | 二级页号 p2 | 页内偏移 d]`
        - `d` 位数 = `log2(页面大小)`
        - 每页能装的 PTE 数 = `页面大小 / PTE大小` → 可编码位数 = `log2(每页PTE数)`，常取给 `p1`、`p2` 等。
    
    ![image.png](assets/image%2017.png)
    
    ### 经典 32 位例（字节寻址，4KB 页，PTE=4B）
    
    - `d` = 12 位；每页 PTE 数 = 4096/4=1024=2¹⁰ → **p1=10 位，p2=10 位，d=12 位**（两级页表）。
    - 好处：
        - 不再要求“页表整体连续”；二级页表**离散**放置；
        - 只把**用到的二级页表**留在内存（其余可不在内存）。
    
    # 3) 地址变换流程（两级页表）
    
    1. 逻辑地址拆段：`p1, p2, d`。
    2. 由 PCB 中的**页目录基址**，用 `p1` 查页目录 → 找到**二级页表所在物理块号**。
    3. 读出该**二级页表**，用 `p2` 找到**目标页的物理块号 f**。
    4. 物理地址 = `(f, d)`（块基址 + 偏移）。
    
    > 例：块号 f=4，4KB 页 ⇒ 块起始 4×4096=16384，若 d=1023 ⇒ 物理地址 16384+1023=17407。
    > 
    
    # 4) 访存次数（必考！）
    
    - **无 TLB**：
        - 单级页表：**2 次**（查页表 + 取目标）。
        - 两级页表：**3 次**（目录 + 二级表 + 取目标）。
        - 一般 **n 级页表 ⇒ n+1 次**。
    - **有 TLB（缓存最终 PTE）**：
        - **命中**：**1 次**（直接取目标）。
        - **未命中**：两级时 **3 次**（目录 + 二级表 + 目标）。
        - 若题目说“TLB 与慢表**并行**查找”，miss 情况**不额外加 TLB 时间**（口径同前一节 TLB）。
    
    # 5) “各级页表≤1页”约束（易错点）
    
    - 多级页表设计时，**每一级的页表大小不得超过一页**。
    - 例（题型）：40 位逻辑地址，4KB 页，PTE=4B
        - `d=12`，剩余 28 位是总页号。
        - 每页 PTE 数=1024→每级最多**10 位索引**。
        - 28 位必须拆成 `8+10+10` ⇒ **三级页表**（p1=8, p2=10, p3=10, d=12）。
        - 若只用两级 ⇒ 某级需 18 位索引，**装不进一页**，不合法。
    
    # 6) 与“虚拟存储/缺页”衔接
    
    - 两级页表解决“连续/常驻”问题；进一步**不常驻**由**虚拟存储**实现：页表项加**存在位**，不存在则**缺页中断**（内中断），把页从外存调入。
    
    # 7) 一屏速背
    
    - 32位 + 4KB + 4B PTE ⇒ **10|10|12**（两级）。
    - **无 TLB：n 级 ⇒ n+1 次访存**；两级=3 次。
    - **TLB 命中=1 次**；未命中（两级）=3 次；并行查找 miss 不再加 TLB 时间。
    - **各级页表 ≤ 1 页**：常用10位/级（4KB 页、4B PTE 时）。
    

### 2.2.段表

# 核心概念

- **分段（Segment）**：按程序**逻辑功能**划分（main、函数、全局数据、局部变量等），**每段内地址从 0 开始**。
- **段表（Segment Table）**：记录段到内存的映射。典型段表项 = **[段长 limit | 基址 base]**（长度固定，段号可隐含）。
- **逻辑地址结构**：`<段号 s, 段内地址 w>`
    - 段号位数 ⇒ **最多段数**；段内地址位数 ⇒ **单段最大长度**（按字节寻址则是 2^w 字节）。

# 地址变换（必背步骤）

![image.png](assets/image%2018.png)

1. 取逻辑地址得到 `s, w`。
2. **段号越界检查**：`s >= 段表长度 m` ⇒ 越界中断。
3. 段表基址 + `s * 段表项长度` ⇒ 取出该段 **[limit, base]**。
4. **段内地址越界检查**：`w >= limit` ⇒ 越界中断。
5. 物理地址 = `base + w`，访问目标单元。

> 对比分页：分页不做“页内偏移越界检查”（页大小固定）；分段必须检查 w < limit（段长可变）。
> 

# 访存次数（考点）

- **分段（无 TLB）**：2 次（查段表 + 访目标）。
- **有 TLB（放段表项副本）**：命中 1 次；未命中仍 2 次。
- （分页单级页表对比：无 TLB 2 次；两级页表 3 次；n 级 ⇒ n+1 次）

# 分页 vs 分段（易混对照）

- **单位**：页＝物理单位；段＝逻辑单位。
- **目的**：分页为**系统管理/离散分配**；分段为**用户友好/按逻辑组织**。
- **是否用户可见**：分页**不可见**；分段**可见**（编程要给段名/段号）。
- **地址空间形态**：分页一维（0…Size）；分段二维（段号 + 段内）。
- **大小**：页固定；段可变。
- **共享/保护**：分段更容易（让多个段表项**指向同一段**，适用于**纯代码/可重入代码**；可对段设权限）。分页做细粒度共享会被“页跨逻辑模块”掣肘。
- **越界检查**：分页无；分段对 `w` 与 `limit` 必检。
- **（拓展常考）碎片**：分页有**内部碎片**；分段易出现**外部碎片**（需紧凑/合并）。

# 快速算式

- 给出：段号位数 `S`、段内位数 `W`（按字节寻址）
    - **最多段数** = `2^S`
    - **最大段长** = `2^W` 字节
- 段表项大小 = `limit位数/字节 + base位数/字节`（通常 base 取决于物理地址位宽）

# 共享与保护（一句话版）

- **共享**：让不同进程段表中的某些表项**指向同一段基址**（仅限不可修改/可重入代码）；
- **保护**：段表项附加访问权限位即可（只读/执行等），粒度自然按逻辑模块。

# 一屏速背

- 逻辑地址：`<s,w>`；**先段号越界，再段内越界**；PA=`base+w`。
- **分段 2 次访存**；TLB 命中 1 次。
- 段号位数 ⇒ 段数；段内位数 ⇒ 段长上限。
- 分段更利于**共享/保护**，但易**外部碎片**。

# 迷你练习（自测 1 分钟）

1. 系统按字节寻址；逻辑地址：段号 14 位、段内 18 位。问：最多可有几段？单段最大多少字节？
    - 答：段数 `2^14=16384` 段；段长 `2^18=256 KB`。
2. 物理内存 4 GB（32 位物理地址），段表项含 `limit(18位)+base(32位)`。段表起始地址为 M。第 s 段表项地址是？
    - 答：`M + s * 50bit` → 按实现需按字节对齐：`(18+32)=50bit` ⇒ 通常取 **8 字节**对齐的表项长度（题目若给定字节数，代入即可）。

### 2.3段页式

# 1. 为啥要段页式？

- **分页优点**：按物理块分配，**无外部碎片**（仅少量内部碎片），内存利用率高。
    
    **缺点**：按物理划分，不便按逻辑模块做**共享/保护**。
    
- **分段优点**：按逻辑模块（代码段/数据段…）划分，易**共享/保护**，用户可见、可读性好。
    
    **缺点**：段需**连续**空间，易**外部碎片**，大段难分配。
    
- **段页式** = 先按逻辑**分段**，再把每段**分页**。既保留分段的逻辑/共享/保护，又用分页的离散分配消除外部碎片。

# 2. 地址结构（一定会考）

逻辑地址三元组：`<段号 s, 页号 p, 页内偏移 d>`

- `s` 位数 ⇒ **每进程最多段数** = `2^s`。
- `p` 位数 ⇒ **每段最多页数** = `2^p`。
- `d` 位数 ⇒ **页大小/物理块大小** = `2^d` 字节。

> 对用户：分段可见（写程序给“段名/段内地址”）。分页对用户不可见（OS把段内地址再切成 p,d）。
> 

# 3. 表项结构（和分段/分页的区别点）

- **段表（每进程 1 张）**：每个段 1 项，典型包含
    - `段号`（可隐含）、**页表长度**、**页表存放块号/基址**。
    
    > 对比“纯分段”的段表项：[段长 limit | 基址 base]（注意不一样！）
    > 
- **页表（每段 1 张，可能有多张）**：每页 1 项，记录**页号→物理块号**（可带存在位、R/W/X 权限等）。
- 段表项、页表项**定长** ⇒ 段号/页号可隐含（靠起始地址+索引算地址）。

# 4. 地址变换流程（无 TLB，三次访存）

![image.png](assets/image%2019.png)

1. 拆逻辑地址得 `s,p,d`。
2. **段号越界检查**：`s ≥ 段表长度` ⇒ 越界中断。
3. 用段表基址 + `s * 段表项长` 取段表项 → 得到**页表基址/块号**与**页表长度**。
4. **页号越界检查**（段内页数可能不同）：`p ≥ 页表长度` ⇒ 越界中断。
5. 访问页表：页表基址 + `p * 页表项长` → 取**物理块号**。
6. **物理地址** = `块号 ⨁ d`（块起址 + 偏移）。
7. 访问目标单元。

> 访存次数：段表(1) + 页表(1) + 目标(1) = 3 次。
> 
> 
> **有 TLB**（以 `(s,p)` 为关键字）：命中则**仅 1 次**（直接目标访存）；未命中仍走 3 次。
> 

# 5. 与分页/分段的对照速记

- **用户可见性**：分页❌；分段✅；段页式=分段✅、分页❌。
- **共享/保护**：段/段页式按段做权限，**天然方便**（多进程段表项指向同一段/同一段内页）。
- **碎片**：段页式以页为分配单位，**外部碎片基本消除**（保留页内小内部碎片）。
- **地址空间维度**：分页=一维；分段、段页式=二维（段×段内）。
- **必检项**：段页式要**检段号**、**检页号**（分段要检 `w<limit`，分页不检偏移）。

# 6. 高频考点/易错点

- **“每段一张页表”**：一个进程只有**一张段表**，但可能有**多张页表**（每段一张，段数多少页表就可能有多少）。
- **TLB 关键字**：用 `(段号, 页号)`；命中无需查段表/页表。
- **同时查找说明**：题目若声明“TLB 与慢表同时查找”，未命中时页表剩余用时要**减去已并行消耗**的那部分。
- **边界**：段号、页号**从 0 开始**；比较是“≥ 长度即越界”。
- **权限位**：按段/页结合出题（例如段只读，页需存在位=1）。
- **计数**：无 TLB 时 n 级页表 = **n+1 次访存**；段页式固定 3 次（段表+页表+目标），有 TLB 命中 1 次。

# 7. 快速口算模板

已知：`s` 位段号，`p` 位页号，`d` 位偏移，按字节寻址

- 段数 = `2^s`；每段最多页数 = `2^p`；页/块大小 = `2^d` B。
- 若给物理地址位宽 `PAbits`，页表项至少需能容纳**块号位数**（≈ `PAbits - d`）+ 状态位。
- 段表项至少要能放**页表长度**（足够容纳 `p` 位范围）+ **页表基址/块号**。

# 8. 迷你练习（10 秒检验）

- 某机：`s=16, p=4, d=12`。问：每进程最多段？每段最多页？页大小？
    - 段数 `2^16=65536`；每段 `2^4=16` 页；页大小 `2^12=4KB`。
- 无 TLB 段页式访问一次逻辑地址要几次访存？
    - **3 次**。

## 二、內存空間的擴充

### 1.覆盖与交换

## 1⃣ 核心定位

- **覆盖（Overlay）**：在**同一程序内部**按调用关系把程序分段；常用段**常驻**，不常用段在**覆盖区按需装入/移出**，用以“塞进”更小的内存。对用户**不透明**，需程序员声明覆盖结构（早期系统常见，现已少用）。
- **交换（Swapping / 兑换）**：在**不同进程之间**，内存吃紧时把某些进程整体**换出到外存**，把急需运行的进程**换入**。由**操作系统**实施，中级调度支撑，用户透明。

---

## 2⃣ 覆盖：

![image.png](assets/image%2020.png)

- **内存布局**：`固定区 + 若干覆盖区`
    - 固定区：放常用/主控段（如 `main`），**装入后不再调出**（至程序结束）。
    - 覆盖区：若干**互斥**使用的模块**共享同一块**空间，**按需**调入/调出。
- **覆盖关系**：依据**模块调用图**，“不可能同时被访问”的模块可共用一个覆盖区。
- **容量计算口诀**：**最小内存 = 固定区大小 + 各覆盖区中“最大模块”之和**
    
    例：`A=8K` 固定；`B(10K)/C(10K)` 互斥 ⇒ 覆盖区1=10K；`D(12K)/E/F` 互斥 ⇒ 覆盖区2=12K
    
    ⇒ **总需 = 8 + 10 + 12 = 30K**（而非所有模块之和）。
    
- **优缺点考点**
    - ✅ 逻辑上“扩容”小内存，能运行大程序
    - ❌ **对用户不透明、编程负担大**、静态僵硬（已被虚拟存储取代多见于早期OS）

---

## 3⃣ 交换：放哪儿、何时换、换谁

- **外存放哪儿**：磁盘分**文件区**与**兑换区（Swap）**
    - **兑换区**侧重**换入/换出速度**，多用**连续分配** ⇒ **I/O 更快**
    - **文件区**侧重**空间利用率**，多用**离散分配**
    - ⇒ 被换出的**进程映像通常放在兑换区**；**PCB 始终常驻内存**（记录其外存位置等）
- **何时触发交换**（内存紧张时）
    - 并发多、**缺页率升高**、系统负荷高时**启动换出**；负荷下降/缺页率回落时**暂停换出**
- **换出谁（选择策略）**
    1. **优先阻塞进程**（反正暂时运行不了）
    2. **低优先级进程**
    3. **考虑驻留时间**：避免刚换入又被换出造成**饥饿**
- **中级调度**：在**挂起队列**中选择外存进程换入；引入**七状态模型**
    - 新增：**就绪挂起**、**阻塞挂起**（原就绪/阻塞被换出后的状态）
    
    ![image.png](assets/image%2021.png)
    

---

## 4⃣ 覆盖 vs 交换（秒选对比）

| 维度 | 覆盖（Overlay） | 交换（Swapping） |
| --- | --- | --- |
| 粒度 | **程序内部**的模块/段 | **整个进程**映像 |
| 谁来管 | **程序员定义**覆盖结构，OS按表装卸 | **OS自动**依据内存压力与调度策略 |
| 目的 | 让**单个大程序**适配小内存 | 提升**多道程序度**、缓解整体内存压力 |
| 存储区 | 固定区/覆盖区 | 兑换区（Swap），**PCB 常驻内存** |
| 透明性 | **不透明**（负担大） | **透明** |
| 现状 | 早期常见，现少用 | 仍是内存管理的重要手段（与虚拟存储协同） |

---

## 5⃣ 易错与必记

- 覆盖区大小按**共享者中的最大模块**定；**固定区不被调出**。
- **交换不动 PCB**；换出的是进程的**数据/代码**等映像。
- **兑换区 I/O 通常快于文件区**（连续分配 vs 离散分配的目标不同）。
- **覆盖在“程序内”**，**交换在“进程间”**——考试常用迷惑项。
- 交换触发可结合**缺页率高**等指标；**中级调度**负责“**换入**谁”。

---

## 6⃣ 一眼分辨口诀

> “覆盖看模块，交换看进程；固定不动，覆盖按需；PCB常驻，兑换更迅。”
> 

### 2.虛擬內存

# 1) 传统内存管理的两大“硬伤”

- **一次性**：作业必须**一次性全部装入内存**才能运行
    
    → 大作业装不下就跑不了；多作业并发度被限制。
    
- **驻留性**：装入后**全程常驻内存**到结束
    
    → 大量暂不用数据长期占内存，利用率低。
    

# 2) 局部性原理（虚拟内存的根）

- **时间局部性**：刚访问过的指令/数据很快还会用（循环、i++…）。
- **空间局部性**：访问某单元后，其**附近**也可能被访问（顺序代码、数组连续存储）。

# 3) 虚拟内存（VM）的定义与三大特征

- 定义：利用局部性，把“近期要用”的少量**页/段**放内存，其余在外存；**按需调入**、必要时**置换**，让用户感觉“内存变大了”。
- 特征：
    - **多次性**：作业可分多次装入。
    - **对换性**：运行中允许在内存与外存**换入/换出**。
    - **虚拟性**：从**逻辑上**扩充内存容量（用户可用的**地址空间 > 物理内存**）。

# 4) 实现虚拟内存的基本条件/支持

- **必须建立在离散分配**之上：分页、分段或段页式（连续分配难以“分批装入”）。
- 在基本管理的基础上新增两套能力：
    1. **请求调入**（请求分页/请求分段/请求段页式）：访问缺页/缺段时，从外存调入→继续执行。
    2. **置换**：内存不够时，挑“暂不用”的页/段换出到外存（配合置换算法）。
- **硬件/系统支持**（考点常见）：
    - 地址转换硬件（页表/段表）＋**存在位**(P)、**修改位**(M)、**引用位**(R)、保护位。
    - **缺页/缺段中断**与异常返回机制。
    - **外存后备**（swap/页面文件/磁盘）与调页 I/O。
    - 可选：**TLB** 加速命中在内存的页表项。

# 5) 与“覆盖 / 交换”的对比（易混点）

- **覆盖**：程序员手工把互斥模块装入同一内存区，**人工管理**、无硬件支持，适合早期/小内存。
- **交换（Swapping）**：以**进程整体**为单位在内外存**整块换进换出**。
- **虚拟内存**：以**页/段**为单位，**按需**自动调入/置换，粒度细、并发高、用户透明。

# 6) 采用 VM 的直接收益

- **能跑大作业**（> 物理内存）；**并发度提高**；**内存利用率**与**CPU 利用率**提升（I/O 与计算重叠、更少“全量等待”）。

# 7) 高频问法速答

- Q：为什么 VM 必须配离散分配？
    
    A：要分批装入/置换，要求**任意页/段可独立装到任意物理块**，连续分配做不到。
    
- Q：缺页发生时系统干啥？
    
    A：产生缺页中断→定位外存页→若无空闲块则置换受害页（若 M=1 先写回）→把新页装入→更新页表/TLB→恢复指令。
    
- Q：VM 与缓存的关系？
    
    A：同属**层次存储+局部性**思想：把“热”数据放高速层（内存/缓存），冷数据留低速层（外存/内存）。
    

### **2.1.1.请求分页管理方式**

# 核心框架（和“基本分页”的对比）

- **请求分页 = 基本分页 + 两大新能力**
    1. **请求调页**：页面不在内存→触发**缺页中断**→从外存调入
    2. **页面置换**：内存无空闲块→按算法挑一页换出
- **地址转换的本质没变**，只是多了：①判断在不在内存；②必要时调页/置换；③更新表项/TLB。

# 页表机制：新增“四件套”

相对基本页表，请求分页的页表多4类信息：

![image.png](assets/image%2022.png)

1. **状态位(P/Present)**：页是否在内存（1在/0不在）
2. **访问字段(Access/Use/时间戳/计数)**：给置换算法用（如“最近一次访问时间”“访问次数”）
3. **修改位(M/Dirty)**：页在内存期间是否被写过；**M=0**换出时**无需写回**
4. **外存地址/磁盘块号**：该页在外存的位置

# 缺页中断（是什么 & 怎么考）

![image.png](assets/image%2023.png)

- **触发契机**：用页表看见 P=0（页不在内存）
- **中断类别**：**内中断**中的**故障(fault)**（可被OS“修复”）
- **一条指令可多次缺页**（例如同时读A、写B，且A、B在不同未驻留页）

# 缺页处理（两种分支）

1. **有空闲块**
    
    找到外存页 → 读入空闲块 → 页表置 P=1、清R/M等必要位 → **把新表项加入TLB** → 进程就绪，重启指令
    
2. **无空闲块（置换）**
    
    选牺牲页（看访问字段等）→ 若**M=1**先写回外存 → 页表清P、失效TLB对应项 → 将目标页读入该块 → 更新页表 & **插入TLB** → 重启指令
    
    （I/O 期间进程**阻塞**，完毕后唤醒）
    

# 地址变换流程（和基本分页的三处“不同”）

![image.png](assets/image%2024.png)

1. **TLB 查找**
    
    命中：直接得物理块号 + 偏移 → 访问；（命中即代表该页**必在内存**）
    
    未命中：查慢表（内存页表）
    
2. **页表命中后的判断**
    
    看 **P**：P=1 正常换算；**P=0 → 缺页中断 → 调页/置换**
    
3. **事件后更新**
    - 读访问：**不改 M**（常考易错！）
    - 写访问：M 置 1
    - **优先改TLB项**（快速路径）；当 TLB 项被淘汰/上下文切换时，再将必要信息**回写**慢表，减少内存写次数

# TLB 相关细节（高频陷阱）

- **TLB 命中 ⇒ 该页一定在内存**（若页被换出，TLB 条目必须同时失效）
- 缺页后调入的新页，**必须把对应表项装入 TLB**（否则下一次还会走慢路径）

# 速记口诀

- **“查TLB—看P位—缺页就I/O；有空就装，没空先挑；脏页先写回，干净直接撂。”**
- **读不脏，写才脏；改TLB，少改表。**

# 易考点清单

- 页表新增字段作用：**P / 访问字段 / M / 外存地址**
- **缺页=内中断·故障**；**一条指令可多次缺页**
- **置换时脏页需写回**，干净页不用
- **TLB 命中**一定在内存；页被换出要**同步失效 TLB**
- 请求分页的地址转换与基本分页相比：**多了在/不在判断 + 调页/置换 + 更新表项/TLB**

# 3 题自测（秒查答案）

1. 读指令访问某页后是否应将该页**修改位**置 1？
    
    → **否**，只有**写**才置 1。
    
2. 为什么 TLB 命中可直接访问而不再判 P 位？
    
    → 因为能进 TLB 的表项必指向**驻留页**；若页被换出，TLB 项需被**同时失效**。
    
3. 置换选中一页但其 M=1，该怎么做？
    
    → **先写回外存**再复用该物理块。
    

### 2.1.2.页面置换算法

# 一、核心目标

- **减少缺页率（Page Fault Rate）** ⇒ 少做慢速磁盘 I/O（换入/换出）。
- 牢记：**缺页次数 ≠ 置换次数**（有空闲帧时缺页但不置换）。

# 二、五大算法一图懂

| 算法 | 英文/缩写 | 核心规则 | 实现难度 | 缺页率 | 是否会出现贝拉迪异常 |
| --- | --- | --- | --- | --- | --- |
| 最佳置换 | OPT | 淘汰“**未来**最久不用/永不再用”的页 | 不可实现（需预知未来） | 理论最优 | 否（栈算法） |
| 先进先出 | FIFO | 淘汰**最早进**内存的页（队列） | 简单 | 较差 | **会**（唯一会） |
| 最近最久未用 | LRU | 淘汰**最近最长时间没用**的页 | 需硬件支持（时间戳/栈） | 仅次于OPT（栈算法） | 否 |
| 时钟（简单） | Clock / NRU | 环形队列+**访问位R**；R=0淘汰，R=1改0再给“二次机会” | 简洁、均衡 | 中上 | 一般不出现 |
| 改进时钟 | Enhanced Clock | R/M二元组：按**(0,0)→(0,1)→(1,0)→(1,1)**优先级扫描 | 稍复杂 | 优于简单Clock | 一般不出现 |

> 栈算法（OPT、LRU）满足“帧数增加 ⇒ 缺页不增”性质，因此不会有贝拉迪异常；FIFO不是栈算法，可能出现。
> 

# 三、手算套路（考场快算）

**通用**

1. 逐个读访问序列；
2. 命中→继续；不命中→缺页++；有空闲帧→装入；无空闲帧→按算法挑牺牲页置换；
3. 末尾算：**缺页率 = 缺页次数 / 访问次数**；如需**置换次数**，只统计“内存已满后的缺页”。

**OPT**：向后“**看未来**”，在当前帧集合里谁**出现得最晚**/不再出现就淘汰。

**FIFO**：维护进入顺序队列，淘汰队头。

**LRU**：向前“**看历史**”，在当前帧集合里谁**上次使用最久远**就淘汰（或用时间戳/栈模拟）。

**Clock（简单）**：环形指针扫；遇R=0→淘汰；遇R=1→置0并继续（**最多两轮**）。

**Enhanced Clock**：加**修改位M**，按优先级找牺牲页（最多**四轮**）：

1. 找(0,0)；
2. 找(0,1)并把扫过页的R清0；
3. 再找(0,0)；
4. 再找(0,1)。

> 直觉：优先淘汰未被改写的“冷页”，减少写回I/O。
> 

# 四、必记细节 & 易错

- **贝拉迪异常**：仅**FIFO**可能出现（帧数增加反而缺页更多）。
- **脏页(M=1)** 置换前**必须写回**外存；**干净页(M=0)** 直接丢弃。
- **Clock名词**：教材里常把“简单Clock”也称**NRU**（与部分书上基于R/M四类的NRU概念略有出入，按王道说法答题即可）。
- **TLB无关置换算法**：TLB命中不触发算法；当页被换出，对应TLB项要**失效**。
- **统计口径**：有空闲帧时的缺页**不算置换**。
- **实现代价**：
    - OPT：仅理论参考。
    - LRU：需硬件（时间戳/栈结构）或近似实现（如Clock）。
    - Clock：性价比高，工程常用；**改进型**进一步降低写回。

# 五、1 分钟速练（附答案）

访问序列：`7 0 1 2 0 3 0 4 2 3 0 3`，帧数=3。

问：在 **FIFO** 与 **LRU** 下缺页次数谁更少？是否可能出现贝拉迪异常？

**秒答**：LRU ≤ FIFO；FIFO 可能出现贝拉迪异常（本序列在3→4帧时可能表现出异常），LRU不会。

# 六、口诀速背

- **OPT**：看未来，最晚来。
- **FIFO**：先来先走，可能反常。
- **LRU**：看历史，久未用走。
- **Clock**：转一圈，R=0走；改进版先(0,0)后(0,1)。
- **脏先写**、**净直接**；**缺页≠置换**要分清。

### 2.1.3.页面分配策略

# 核心概念

- **驻留集（Resident Set）**：当前已分给某进程、实际驻留内存的**物理块集合**。大小常小于进程总页数。
- 驻留集太小 ⇒ 缺页频繁；太大 ⇒ 并发度下降、资源利用率低。

# 三种“分配×置换”策略（只存在三种）

1. **固定分配 + 局部置换**
    - 进程启动时分到固定帧数，运行期**不变**；缺页时**只能在本进程帧内**换出。
    - 难点：启动时很难一次性给“刚好合适”的帧数；灵活性差。
2. **可变分配 + 全局置换**
    - 缺页就**从系统空闲帧**给它；若无空闲，可把**其他进程**未锁定页换出再给它。
    - 进程缺页就几乎“必增帧”，但会干扰他人，系统波动大。
3. **可变分配 + 局部置换**（更合理）
    - 缺页只在**本进程**帧内置换；系统**根据缺页率**动态增/减该进程帧数，平衡并发度与性能。

> 记牢：没有“固定分配 + 全局置换”（固定≠会变，全局⇒会变，矛盾）。
> 

# 何时调入页面（时机）

- **预调页（Prepaging）**：利用**空间局部性**，一次预取一组相邻页；I/O 次数少，但预测成功率有限（~50%），常用于**进程初次装入**，可由程序员标注关键段。
- **请求调页（Demand Paging）**：**缺页时**才调入，必然用得到，但每次只进1页，I/O 开销多。

> 实际系统：先预调（冷启动），运行期以请求调页为主。
> 

# 从哪里调入 / 调出（介质）

- 磁盘分区：**交换区（swap/交换分区）读写快**、连续分配；**文件区**读写**慢**、离散分配。
    1. **交换区足够**：内存↔交换区 之间进出（运行前可把程序从文件区复制到交换区）。
    2. **交换区紧张**：**只读/未改动**页从**文件区直接**调入；被修改页换出到**交换区**。
    3. **Unix常见做法**：**首次使用**从文件区装入；之后若换出则写到交换区；再用时从交换区装回。

# 抖动 / 颠簸（Thrashing）

- **定义**：刚换出的页立刻又要换入；刚换入又很快被换出 ⇒ **频繁 I/O**，CPU 利用率低。
- **根因**：某段时间内**活跃工作集 > 已分配帧数**（驻留集太小）。
- **症状**：缺页率飙升、I/O 忙、CPU 空转。
- **对策**：给该进程**增加帧数**、降低系统并发度、采用**工作集**或**缺页率控制**分配策略、锁内核关键页。

# 工作集（Working Set）

- **定义**：进程在过去一段窗口 **Δ**（按时间或按最近K次引用）内**实际访问的不同页**集合，记作 **W(t, Δ)**。
- **性质/用法**：
    - 一般有 **|驻留集| ≥ |工作集|** 才能避免抖动。
    - Δ 越大，工作集上界越大；局部性好时，工作集远小于 Δ。
    - 可用于分配：按观测到的工作集大小，**动态增减帧**；用于置换：优先淘汰“不在工作集”的页。

![image.png](assets/image%2025.png)

- **小例**：访问串 …, 2,4,5,1,8,2,3；Δ=4，位于“8”的时刻往前看4次 ⇒ 工作集 {1,8,2,4}（去重）。

# 易考点 & 易混点

- **驻留集 vs 工作集**：驻留集=“现在在内存的帧”；工作集=“最近实际用到的页集合”。
- **全局 vs 局部置换**：
    - 全局：缺页**可拿新帧**或动别人帧（波动大，可能更高吞吐）。
    - 局部：只动自己帧（更可控，稳定）。
- **锁定页**：关键内核/驱动页可能**不可置换**。
- **统计**：缺页发生≠一定置换（有空闲帧不置换）。

## 三、內存映射文件

# 是什么 & 有啥用

- **系统调用能力**：把“文件的一段”直接**映射到进程虚拟地址空间**的一段。返回起始指针，后续像**访问内存**一样读/改文件内容。
- **两大作用**
    1. **简化文件访问**：免去反复 `read/write`；按指针+偏移直接读写。
    2. **数据共享**：多个进程把**同一文件**映射到各自地址空间，页表同时指向**同一物理页** ⇒ 彼此可见。

# 和传统 read/write 的对比

- 传统方式：`open → lseek → read(拷到用户缓冲) → (修改) → write(写回磁盘) → close`，每次读写都要**系统调用 + 拷贝**。
- 内存映射：`open → mmap(建映射, 仅建立关系) → 像数组一样访问 → close`
    - 首次触及某页触发**缺页异常**，OS 才把**对应文件块**读入物理页（**懒加载**）。
    - 修改发生在**内存页**，`close` 时 OS 会把**被修改的页**写回（未改的不写）。

# 工作原理（按你视频里的模型）

![image.png](assets/image%2026.png)

- **只建映射不立刻读**：mmap 后，文件块先标灰（未入内存）。
- **按需调页**：访问到哪一块，哪一块**缺页中断**→ 从磁盘把该块读入物理页。
- **写回策略**：映射页若被修改，**关闭文件**时由 OS 写回磁盘（未改的无需写回）。
- **共享实现**：把进程1和进程2映射区的页表都指向**同一物理页框**，一方修改另一方**立刻可见**。

# 典型流程（概念版）

1. `open("file")`
2. `mmap` → 得到起始地址 `p`
3. 用 `(p + offset)` 读写数据（像内存一样）
4. 访问未入内存的页 ⇒ **缺页** ⇒ OS 从文件把该页**读入**
5. 若修改过，`close` 时 OS 把**改过的页**写回

# 优点 / 考点

- **代码更简洁**、少系统调用；按需加载减少无用 I/O；OS 可统一做**预读/缓写**优化。
- **多进程共享**：通过同物理页实现；共享读写天然一致。
- **关键词**：懒加载、缺页异常、按需调页、共享同物理页、写回仅限已修改页。

# 易混/易考提醒

- `mmap` 只是**建立映射**，**不等于立刻读入**。
- 发生 I/O 的时机由**缺页**与**写回**决定，**OS 说了算**（还能做预读/缓写）。
- 两个进程能共享，是因为**页表→同一物理页**，不是因为“虚拟地址相同”。