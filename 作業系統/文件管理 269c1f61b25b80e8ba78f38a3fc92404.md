# 文件管理

上次編輯時間: 2025年9月17日 下午4:57
建立時間: 2025年9月9日 下午5:34

## 概論

---

# 一图记忆（上到下）

```
用户/应用
   │  系统调用接口：open / read / write / close / unlink …
┌──┴──────────────────────────────────────────┐
│ ① 用户接口层（User Interface）             │  ← 负责接系统调用
└──┬──────────────────────────────────────────┘
    │  路径解析 / 目录遍历 / 打开文件表维护
┌───┴─────────────────────────────────────────┐
│ ② 文件目录系统（Directory System）          │  ← 管理目录、FCB/inode、打开文件表
└───┬─────────────────────────────────────────┘
     │  访问控制决策（是否有权）
┌────┴────────────────────────────────────────┐
│ ③ 存取控制模块（Access/Protection）         │  ← ACL/口令/权限检查
└────┬────────────────────────────────────────┘
      │  记录号→逻辑地址；需要索引表就先调入缓存
┌─────┴───────────────────────────────────────┐
│ ④ 逻辑文件系统 & 文件信息缓冲区（LFS & FIB）│  ← 逻辑结构/索引文件/缓存索引表
└─────┬───────────────────────────────────────┘
       │  逻辑地址→物理地址
┌──────┴──────────────────────────────────────┐
│ ⑤ 物理文件系统（Physical FS）               │  ← 物理结构：连续/链接/索引分配
└──────┬──────────────────────────────────────┘
       │  申请/回收盘块、维护空闲结构
┌───────┴─────────────────────────────────────┐
│ ⑥ 辅助分配模块（Space Mgmt）                │  ← 空闲表/空闲链/位示图/成组链接
└───────┬─────────────────────────────────────┘
        │  I/O调度、缓存、与硬件对话
┌────────┴────────────────────────────────────┐
│ ⑦ 设备管理模块（Device Mgmt）               │  ← 磁盘调度、设备/缓冲区分配、启动I/O
└─────────────────────────────────────────────┘
硬件：磁盘/控制器

```

---

# 各层职责一句话表

| 层次 | 关键职责 | 你要记住 |
| --- | --- | --- |
| ① 用户接口 | 接收系统调用 | open/read/write/close 等入口 |
| ② 目录系统 | 路径解析、目录/打开文件表 | 打开=把目录项搬到“打开文件表” |
| ③ 存取控制 | 权限判定 | ACL/口令/组权限，**在这层拦** |
| ④ 逻辑文件系统 & 缓冲区 | 记录号→逻辑地址、索引表入内存 | 索引文件先把索引表读到**文件信息缓冲区** |
| ⑤ 物理文件系统 | 逻辑→物理 | 映射到具体盘块 |
| ⑥ 辅助分配 | 盘块分配/回收 | 空闲表/链/位示图/成组链接法 |
| ⑦ 设备管理 | 真正I/O | 磁盘调度、DMA/中断、设备缓冲 |

---

# 经典流程背一遍：删除“学生信息.xlsx”最后 100 条记录

1. **用户接口**：进程发出“删记录”系统调用。
2. **目录系统**：按路径找目录项→定位 FCB/inode，维护打开文件表。
3. **存取控制**：检查是否有“写/修改”权限（无则拒绝）。
4. **逻辑文件系统**：将目标记录号→逻辑地址；需要时把索引表读入**文件信息缓冲区**。
5. **物理文件系统**：逻辑地址→物理盘块地址。
6. **设备管理**：执行实际磁盘 I/O（可能结合缓存、调度）。
7. **辅助分配**：如释放形成空闲块→按位示图/空闲表等**回收**并更新空闲结构。

---

# 易混/易考点

- **打开文件 ≠ 读文件**：open 只把**目录项搬到内存的打开文件表**；read 才读数据。
- **权限检查在哪层？** 在**存取控制模块**（第③层）。
- **记录号如何落盘？** 记录号→（④）逻辑地址→（⑤）物理地址→I/O。
- **索引文件的索引表放哪儿再用？** 放**文件信息缓冲区**（④）后再查。
- **分配/回收空闲块是谁？** **辅助分配模块**（⑥）。
- **最靠近硬件的是？** 设备管理模块（⑦）：磁盘调度、启动/结束 I/O、设备缓冲。
- **层次与前面章节对应**：
    - 基本操作→①；目录→②；保护→③；逻辑结构→④；物理结构→⑤；存储空间管理→⑥；磁盘管理→⑦。

---

# 5 题快测

1. 路径解析与维护打开文件表属于哪层？→ **② 文件目录系统**。
2. 检查“写”权限属于哪层？→ **③ 存取控制**。
3. 记录号→逻辑地址属于哪层？→ **④ 逻辑文件系统**。
4. 位示图/成组链接法归哪层？→ **⑥ 辅助分配**。
5. 磁盘调度（如电梯算法）在哪层？→ **⑦ 设备管理**。

---

# 一、两次“格式化”各干啥？

**1) 物理/低级格式化（出厂或底层）**

![image.png](assets/image%2027.png)

- 作用：把磁盘划成**扇区**；**检测并重映射坏扇区**到备用扇区。
- 关键点：坏扇区对OS**透明**（驱动层用备用扇区替代）。

**2) 逻辑/高级格式化（装系统/建卷）**

![image.png](assets/image%2028.png)

- 作用：把磁盘划成**分区/卷（C/D/E…）**；每个卷内**建立文件系统**的基本结构。
- 分区表：记录各分区的起止LBA与大小。

---

# 二、卷内（磁盘上）典型布局（以UNIX风格为例）

```
[Boot/引导块] [Super Block/超级块] [Free-Space结构(位示图/成组信息)]
[i-Node区(索引节点表, 连续)] [根目录] [数据区(文件/子目录数据)]

```

- **引导块**：分区引导信息（可选）。
- **超级块**：卷的“总账本”，如总块数、空闲统计、关键位置。→ **快速找到一批空闲块**。
- **空闲空间结构**：常见**位示图(bitmap)**（0空闲/1占用，**快速判断某块是否空闲**）；或成组链接信息。
    - 超级块与位示图功能有重合，但定位目标不同：**“批量拿块”vs“判断某块是否空闲”**。
- **i节点区**：所有inode**连续存放**，同大小；可据**inode号**快速算位置（起址 + 号×大小）。
- **根目录**：逻辑格式化时即建立；后续自此生长目录树。
- 逻辑格式化后：灰色区（已有元数据），白色区（待放文件/目录）。

---

# 三、内存中的文件系统全局结构

![image.png](assets/image%2029.png)

- **系统OFT**：一份/系统；**打开计数**支撑“是否仍被占用”。
- **进程OFT**：多份/进程；保存**访问模式**、**读写指针**；指向系统OFT的**索引**。
- **目录缓存**：加速路径解析（避免反复磁盘查目录）。

---

# 四、open/read 实际怎么走？

以 `open("…/m/a", flags)` → `read(fd, buf, n)` 为例：

**open()**

1. 路径解析：逐级查目录（命中则多从**目录缓存**取），找到 **a 的目录项/FCB(inode)**。
2. 将 a 的 FCB 拷入**系统OFT**生成条目，**打开计数=1**（或+1）。
3. 在**进程OFT**新建条目：记录**访问方式**（只读/读写）、**读写指针**、以及→系统OFT条目的**索引**。
4. 返回**文件描述符fd**（本质：指向本进程OFT条目的索引）。

**read(fd)**

1. 由fd定位**进程OFT**→找到**系统OFT**→拿到**FCB/inode**。
2. 由FCB得到文件的**逻辑结构信息**，把**当前读写指针**映射到**逻辑块**，再映射到**物理块**。
3. 走**设备管理/I/O路径**把数据读入内存，更新读写指针。

> 牢记：open 并不读入文件数据，只把目录项→打开表；read/write 才进行真正I/O。
> 

---

# 五、考点与易混

- **物理vs逻辑格式化**：前者**扇区+坏块重映射（透明）**，后者**分区+建FS结构**。
- **超级块 vs 位示图**：都与空闲相关；**超级块**偏“总览与快速拿一组空闲块”，**位示图**偏“按位判断/精确定位”。
- **inode区连续 & O(1)寻址**：起址+编号×大小。
- **系统OFT vs 进程OFT**：
    - 系统OFT：**打开计数、共享元信息**；
    - 进程OFT：**访问权限、读写指针、→系统OFT索引**。
- **文件描述符**：索引的是**进程OFT**，不是系统OFT/目录项。
- **目录缓存**：加速路径解析；与页缓存/数据缓存概念区分开。

---

# 六、3题自测

1. 坏扇区对OS透明靠哪一步实现？→ **物理格式化阶段的坏块重映射**。
2. 哪个结构支持“一次拿出多块空闲块”？→ **超级块（配合成组/链信息）**。
3. `read(fd)` 如何定位到磁盘块？→ **fd→进程OFT→系统OFT→FCB/inode→逻辑→物理→I/O**。

# **文件系统初识&** 文件的逻辑结构

# 你要抓的主线

- **文件=数据集合**，OS 必须管理它的：属性 → 逻辑组织 → 目录组织 → 上层接口（系统调用）→ 底层物理存放（磁盘块）。
- “逻辑结构”说**文件内部记录怎么组织**；“物理结构”说**在磁盘上怎么摆**。

# 一、文件有哪些属性（会考名词&理解题）

- **文件名（Name）**：用户用它找文件；*同一目录*内不得重名。
- **标识符（ID/i-node 号）**：系统内部**唯一**识别，不给用户看。
- **类型（Type）**：决定默认打开程序、处理方式（.txt/.pdf/.mp4…）。
- **位置（Location）**
    - *路径*：给用户用（如 D:\demo\test.txt）。
    - *物理位置*：给 OS 用（在哪些磁盘块）。
- **大小（Size）**、**时间戳（创建/修改）**、**所有者/属组**、**保护信息（权限/ACL）**。

# 二、目录&文件组织（外在层级）

- 目录（文件夹）也是**特殊有结构文件**；常见是**树/层次结构**：根目录 → 子目录/文件。
- 同名允许出现在**不同目录**；**同目录不允许**。

# 三、OS 给上层的基本操作（系统调用六兄弟）

- `create` 创建、`delete` 删除
- `open` 打开、`close` 关闭（**与双击/点叉不是一件事**）
- `read` 读入、`write` 写回
- 复杂操作=基本操作的组合（如复制= `create` 新文件 + 循环 `read`/`write`）。

# 四、外存基本面貌（会出小计算）

- 磁盘按**块（block）**管理与传输；块大小常为 2 的幂（如 1KB）。
- **逻辑地址 = 逻辑块号 + 块内地址**；**物理地址 = 物理块号 + 块内地址**。
- **块内地址位数 = log₂(块大小字节)**。例：1KB=1024B ⇒ 位数=10。
- 分配/读写都以**块**为单位；小文件也至少占 1 块（内部碎片）。

---

# 五、文件的逻辑结构（重头戏）

## 0）两大类

- **无结构文件（流式）**：二进制/字符流，例如 `.txt`。
- **有结构文件（记录式）**：由**记录**组成，记录由**若干数据项**构成；可有**关键字**。
    - **定长记录** vs **可变长记录**（现实里可变长很常见，如“特长”字段）。

## 1）顺序文件（Sequential）

- **按记录顺序排放**（默认物理上“顺序存储”来讨论）。
- 两种排列：
    - **串结构**：与关键字无关（按到达时间等）；**检索靠顺扫**。
    - **顺序结构**：按关键字有序；可**折半查找**。
- **能否随机存取（定位第 i 条）？看两个条件**
    - 物理上**链式存储**：❌ 不能随机（像链表）。
    - 物理上**顺序存储**：
        - **可变长记录**：❌ 不能（长度不等，偏移不可直接算）。
        - **定长记录**：✅ 能（地址 = 基址 + i×L）。
- **插删**：顺序存储下成本高；若是**串结构**，可“尾插+日志合并”减轻成本（理解即可）。

## 2）索引文件（Indexed）

- 为文件建**索引表**：**每条记录对应一个索引项**（定长），索引项里有“索引号/关键字 + 指针”。
- 优点：**支持随机访问**、**检索快**（索引表可按关键字有序 ⇒ 折半）。
- 代价：索引表**空间开销大**（一条记录配一条索引项）。
- 可对**多个字段**建多张索引（学过 DB 的“二级索引/辅助索引”同理）。

## 3）索引顺序文件（Indexed-Sequential，ISAM 思想）

- 兼顾“**检索快** & **索引小**”：
    - 记录先**分组（桶）**，**每组对应一个索引项**（不是每条记录一个）。
    - 每组内部是**顺序文件**；索引表是**定长记录的顺序文件（通常串结构）**。
- **平均查找次数**（单级）：≈ **索引表项数/2 + 组内记录数/2**。
    - 例：总 10 000 记录 → 100 组 × 100：平均 ≈ 50（索引）+ 50（组内）= **100** 次。
- **多级索引**：再给“若干低级索引表”建一个**顶级索引** → 平均次数约为**各层/2 之和**（大幅降低）。

---

# 六、超高频考点&易错点

- **“同目录不可重名”**；**文件名≠唯一标识**，系统靠**标识符**区分。
- **随机存取判定**：
    - **定长 + 物理顺序** ⇒ ✅；其余情况（链式 或 可变长） ⇒ ❌。
- **顺序结构**才能**折半查找**；串结构只能**顺扫**。
- **索引文件 vs 索引顺序文件**：
    - 前者：**一记录一索引项**、更快但更占空间；
    - 后者：**一组一索引项**、空间小、查找≈“查索引+查组内”。
- **块内地址位数**要会算（log₂ 块大小字节）。
- **系统调用 open/close** 是文件使用的**前后必备动作**，和 GUI 点窗口不是一码事。

---

# 七、1分钟自测

1. 1KB 块大小的磁盘，**块内地址需要多少位**？→ **10 位**。
2. “物理链式 + 可变长记录的顺序文件”能否随机存取？→ **不能**（链式已经不能）。
3. “定长记录 + 顺序结构”的顺序文件能否快速按关键字检索？→ **能**（折半）。
4. ISAM 单级：索引 200 项、组内 50 项，平均比较≈？→ **100 + 25 = 125** 次。
5. 同一目录能否有两个同名文件？→ **不能**；不同目录可以。

## 文件目录

# 目录核心图景

- **目录文件** = 特殊的有结构文件；内部是**一条条目录项**（记录）。
- **目录项 = `FCB`（File Control Block，文件控制块）**
    
    最关键两件：**文件名** ✚ **物理地址/指向文件位置的信息**（其余属性：类型、大小、时间戳、权限、拥有者、逻辑/物理结构等）。
    
- **按名存取**：靠“文件名 → 目录项（FCB） → 物理地址”的映射链实现。
    
    ![image.png](assets/image%2030.png)
    

# 目录需要的操作

- **创建文件**（在所属目录中**增**目录项）
- **删除文件**（删数据 + **删目录项**）
- **修改属性**（改目录项中的属性字段）
- **搜索目录**（按文件名找目录项）
- **显示目录**（罗列目录项）

# 目录结构 4 种（会考优缺点）

1. **单级目录**
    - 全系统一张目录表；**支持按名存取**；**不允许重名** → 多用户下严重冲突。
        
        ![image.png](assets/image%2031.png)
        
2. **两级目录（MFD + UFD）**
    - MFD：用户名 → 对应 UFD 位置；UFD：该用户所有文件的 FCB。
    - **不同用户可重名**；易做**访问限制**；**用户内不可分类**。
    
    ![image.png](assets/image%2032.png)
    
3. **多级/树形目录**（现代主流）
    - 目录可套目录；**不同目录可重名**；层次清晰、易管理与保护。
    - **不便共享文件**（高频考点）。
    
    ![image.png](assets/image%2033.png)
    
4. **无环图（DAG）目录**
    - 在树上加“指向同一节点”的边（不成环）→ **方便共享文件/目录**。
    - **共享计数器**：目录项删一处仅让计数–1；**计数为 0 才真正删除**。
    - **共享≠复制**：共享改动互见；复制互不影响。

# 路径 & I/O 次数（易考理解题）

- **绝对路径**：从根开始 `/root/.../file`。
    
    查找需要**逐级读入各级目录文件**：I/O 次数 ≈ 目录层数。
    
- **相对路径**：从**当前目录**出发 `./sub/.../file`。
    
    常访问同一目录下多文件时，把该目录设为**当前目录**，可**少读若干级目录**（I/O 次数更少）。
    

# 索引结点（inode）—对 FCB 的优化

- 思想：**目录项瘦身**，只保留**文件名 + 指向 inode 的指针**；
    
    **inode**里放：类型、大小、时间、权限、**物理地址信息**、链接计数等。
    
- 好处：**一个磁盘块能装更多目录项 → 搜索目录时读盘次数显著下降**。
    
    典型对比（记忆法）：
    
    - 目录项=FCB（64B）→ 1KB 一块 **≈16 项/块** → 搜 320 项 ≈ **20 块 I/O**；
    - 目录项=“文件名(≈14B)+inode 指针(≈2B)” → **≈64 项/块** → 搜 320 项 ≈ **5 块 I/O**。
- **磁盘 inode**：在外存；**内存 inode**：被打开时载入，额外维护“是否被改”“被多少进程占用”等运行时信息。

# 高频对比 & 易错点

- **目录文件本身就是文件**（有结构、记录式）。
- **按名存取**靠目录 → 找到 inode/FCB → 再定位数据。
- **树形目录不便共享**；**DAG 目录易共享 + 需要引用计数**。
- **共享删除**要看**计数**；复制删除互不影响。
- **相对路径可减少 I/O**（因为可从已在内存的“当前目录”开始）。
- **两级目录**解决了“多用户重名”，但**无法在用户内部再分层分类**。

# 1 分钟自测

1. 为什么 inode 能降低查目录的 I/O？
    
    → 目录项更短、同一块能装更多项，顺扫同样条目需要更少磁盘块。
    
2. 树形目录下，`/a/b/c/d.jpg` 的定位需要几次读盘？
    
    → 约等于层数（a、b、c 三级目录各读一次；若 c 目录已是**当前目录**，只需读 c→d 这一级）。
    
3. 共享与复制的根本差异？
    
    → 共享多目录项→**同一个文件数据/同一 inode**；复制→**新的数据副本/新 inode**。
    
4. 两级目录能否同用户内重名？
    
    → 不能；**不同用户之间**可重名。
    
5. DAG 目录何时真正删除共享文件？
    
    → **引用计数=0** 时。
    

## 文件的物理结构

# 核心总览

- 外存以**块**（磁盘块/物理块）为单位；文件的逻辑地址＝**逻辑块号 + 块内地址**。
    
    块内地址原样沿用，**重点是把逻辑块号 → 物理块号**。
    
- 三大分配方式：**连续分配**、**链接分配**（隐式/显式 FAT）、**索引分配**（单层、多层、混合）。

---

# 连续分配（Contiguous）

![image.png](assets/image%2034.png)

**记录在 [FCB](%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%20269c1f61b25b80e8ba78f38a3fc92404.md)**：起始块号 + 长度（块数）

**地址变换**：`物理块号 = 起始块号 + 逻辑块号`（O(1)）

<aside>
💡

**优点**

- ✅ 支持**顺序访问 + 随机访问**（直接访问最快）
- ✅ **顺序读写最快**（磁头移动距离最小）

**缺点**

- ❌ **扩展困难**（后面不连续就要整体搬家）
- ❌ **外部碎片**多、空间利用率低（需紧凑=代价大）
</aside>

**典型考点**：给你起始块 & 长度，直接算物理块；问顺序/随机访问性能。

---

# 链接分配（Linked） 隐式链接

思路：文件占用**离散块**，用“链”把块串起来。

![image.png](assets/image%2035.png)

## 1) 隐式链接（每个数据块里放“下一块指针”）

**FCB**：起始块号（常配合保存结束块号）

**找第 i 个逻辑块**：必须从头**顺序跟链 i 次**

→ **仅支持顺序访问**；访问第 i 块需 **i+1 次磁盘 I/O**（块块都要读）

<aside>
💡

**优点**：易扩展、无外部碎片

**缺点**：随机访问差；每块有指针开销；指针损坏风险

</aside>

> 题目只写“链接分配”未指明是哪种时，默认是隐式链接（高频陷阱）。
> 

## 2) 显式链接（FAT：File Allocation Table）

把“下一块指针”**集中放在一张表**里（**每个磁盘只有一张 FAT**），**开机载入内存并常驻**。

![image.png](assets/image%2036.png)

**FCB**：起始块号

**找第 i 块**：在内存中的 FAT 里沿链走 i 次（**不读盘**），最后**只读目标数据块 1 次**

→ **顺序 + 随机访问都可**（随机访问比隐式快很多）

---

<aside>
💡

**优点**：易扩展、无外部碎片、因 FAT 在内存里**查找快**

**缺点**：FAT 可能很大（但只占内存一次）

</aside>

**典型考点**：

- “FAT 是否每个文件一张？”→ **否**，**每个磁盘**一张。
- “为何 FAT 方式支持随机访问？”→ 查链在内存，不需逐块读盘。

---

# 索引分配（Indexed）

![image.png](assets/image%2037.png)

每个**文件**自带一张**索引表**（类似“页表”），表项存**数据块号**。

**索引块**：存索引表的那个块；**数据块**：存文件数据的块。

**FCB**：索引块号（或顶级索引结构）

**访问第 i 块**

- 单层索引：读索引块（1 次）→ 查到物理块号 → 读数据块（1 次）= **2 次 I/O**
- 多层/混合：见下

<aside>
💡

**优点**：✅ 支持随机访问；✅ 扩展容易（加表项/新块）

**缺点**：❌ 索引表占空间（但可用多层/混合优化）

</aside>

## 索引表装不下的三种方案

### a) 链接方案（索引块之间再链起来）

- 找较后面的索引块前，要**先读前面所有索引块** → 查找效率差（可能大量 I/O）
    
    ![image.png](assets/image%2038.png)
    

### b) 多层索引（k 级）

![image.png](assets/image%2039.png)

- 类似多级页表。
- **文件最大长度**（块数）≈ 每层可索引项数的连乘。
    
    若：块大小 = 1KB；每表项 4B → 每块可容纳索引项 **256** 个
    
    - **2 级索引**：最大块数 = 256 × 256；最大文件 = 256×256×1KB = **64MB**
    - **3 级索引**：最大块数 = 256³；最大文件 = **16GB**
- **访问 I/O 次数**：若顶级索引块 **不在内存**，访问数据块需 **(k + 1) 次读盘**
    
    （读第1级索引 + 读第2级索引 + … + 读第k级索引 + 读数据）
    

### c) 混合索引（直接 + 1级间接 + 2级间接…）

![image.png](assets/image%2040.png)

- 顶级“索引块”中同时放：
    
    **若干直接地址**（直接指数据块）+ **若干 1 级间接** + **若干 2 级间接** …
    
- 例：顶级含 **8 个直接**、**1 个一级间接**、**1 个二级间接**（块=1KB、表项=4B）
    - 直接：8 块
    - 一级：256 块
    - 二级：256×256 块
    - **最大块数** = 8 + 256 + 65536 = **65800 块** → 最大文件 ≈ **64.3MB**
- **访问 I/O 次数**（顶级索引块不在内存时）：
    - 访问**直接**区域：读顶级索引(1) + 读数据(1) = **2 次**
    - 访问**一级间接**：顶级(1) + 一级索引(1) + 数据(1) = **3 次**
    - 访问**二级间接**：顶级(1) + 二级索引(1) + 一级索引(1) + 数据(1) = **4 次**

**混合索引优点**：小文件访问更少 I/O（现实中文件“小而多”）→综合性能佳。

---

# 一表秒记（顺/随机、扩展、碎片、I/O）

| 分配方式 | 顺序访问 | 随机访问 | 扩展 | 碎片 | 典型访问 I/O（不含缓存） |
| --- | --- | --- | --- | --- | --- |
| 连续 | ✅ 最快 | ✅ O(1) | ❌ 困难 | ❌ 外部碎片 | 读第 i 块：**1 次** |
| 链接-隐式 | ✅ | ❌ | ✅ 容易 | ✅ 无外部碎片 | 读第 i 块：**i+1 次** |
| 链接-FAT | ✅ | ✅（在内存查 FAT） | ✅ | ✅ | 查表内存走链 + **读数据 1 次** |
| 索引-单层 | ✅ | ✅ | ✅ | ✅ | **索引 1 + 数据 1 = 2** |
| 索引-多层(k) | ✅ | ✅ | ✅ | ✅ | **k（索引层）＋1（数据）** |
| 索引-混合 | ✅ | ✅ | ✅ | ✅ | **2~4 次**（随访问层级而变） |

---

# 高频陷阱 & 提示

- “链接分配”未注明 FAT/显式时，**默认隐式链接**。
- **FAT**：**每个磁盘一张**，开机读入内存；之所以支持随机访问，是因为**查链在内存**。
- **连续分配**顺序读**最快**（磁头移动最小）；但**扩容最痛**。
- **最大文件长度**题：牢记“**每级索引表 ≤ 1 个磁盘块**”，用“每块可容纳表项数”的**连乘**。
- **访问 I/O 次数**题：从“是否先读顶级索引块”开始数层级即可（顶级若已在内存，次数-1）。

---

## 文件逻辑结构 vs 物理结构

# 一页总览

**两个视角：谁关心什么？**

| 维度 | 逻辑结构（用户/程序员视角） | 物理结构（OS视角） |
| --- | --- | --- |
| 我在意的 | 记录怎么组织、怎么查到目标记录/字节 | 块怎么分配、怎样把逻辑地址落到磁盘块 |
| 典型形式 | 无结构（流式）、有结构：顺序/索引/索引顺序 | 连续分配、链接分配、索引分配 |
| 我看到的地址 | 逻辑字节偏移、记录号 | 物理块号 + 块内偏移 |
| 谁维护“索引” | 逻辑结构里的**索引文件**：关键字→**记录逻辑地址** | 物理结构里的**索引分配**：**逻辑块号**→**物理块号** |

> 口诀：逻辑看“记录/关键字”，物理看“块/映射”。
> 

---

# 无结构文件（流式）

- 特点：就是一串字节。应用只看到**逻辑偏移**。
- C常用套路：`fopen`→`fseek(fp, off, SEEK_SET)`→`fgetc/fread`。
- 背后：OS把逻辑偏移 ⇒ (逻辑块号，块内偏移) ⇒ 物理块号（由其分配策略决定）。

---

# 有结构文件：顺序文件

## 两种实现（逻辑层）

1. **顺序存储**（定长记录常见）
    - 记录等长，按逻辑顺序**顺排**。
    - 定位第 *i* 条：O(1)。
    - C里常见：`fseek(fp, i * sizeof(record), SEEK_SET); fread(...)`
2. **链式存储**（逻辑“链”）
    - 每条记录带 `next` 指针（记录**逻辑上的**相邻关系）。
    - 定位第 *i* 条通常 O(i) 顺链而下。
    - 注意：这是**用户自定义的逻辑链**，不代表磁盘上物理相邻。

> 易混点①：链式存储（逻辑） ≠ 链接分配（物理）
> 
> - 逻辑链式：记录里有 next，**你**来设计和维护。
> - 物理链接分配：OS把文件的**逻辑块**用磁盘块链起来（FAT/显式表），**OS**维护。

---

# 索引文件（逻辑） vs 索引分配（物理）

- **索引文件（逻辑）**
    - 由“**索引项**(关键字, 记录逻辑地址)”组成的索引区 + 数据区。
    - 作用：按关键字高效定位到**记录的逻辑地址**。
- **索引分配（物理）**
    - OS为文件建**索引表**：`逻辑块号 → 物理块号`（一级/多级/混合）。
    - 作用：把应用给的逻辑块号映射到磁盘块。

> 易混点②：同叫“索引”，指向的对象不同：
> 
> 
> 逻辑索引指**记录**；物理索引指**块**。
> 

---

# 访问路径（统一心智模型）

1. 应用给出目标：**逻辑字节偏移**或**第 i 条记录**
2. 转 **逻辑块号 LB** 与 **块内偏移 off**
3. 用物理结构（连续/链接/索引分配）把 **LB → 物理块号 PB**
4. 物理 I/O：读 PB，再用 off 取出目标

**常用小公式（定长记录，块大小 = B，记录长 = L，记录序号 i 从 0 起）：**

- 记录起始逻辑偏移：`i * L`
- 逻辑块号：`LB = floor((i * L) / B)`
- 块内偏移：`off = (i * L) % B`

---

# 索引顺序文件（逻辑提一嘴）

- 记录**按关键字顺序**存放 + **稀疏索引**（可分多级）。
- 逻辑结构决定“怎么找记录”，**不等于**物理上必须连续；物理仍可选连续/链接/索引分配。

---

# C 代码要点（映射到概念）

- `fopen` / `fclose`：打开/关闭文件对象
- `fseek`：设置**逻辑偏移**（不是物理）
- `fread`/`fwrite`：批量按**记录长度**读写（顺序存储好搭档）
- 自建“索引文件”：在文件前部放一段索引项数组（key, 逻辑地址），先读索引区再跳转到数据区

---

# 高频易错速查

- 逻辑“链式存储”与物理“链接分配”不是一回事 ✅
- 逻辑“索引文件”的索引项包含关键字和**记录逻辑地址**；物理“索引分配”的索引项是**逻辑块→物理块** ✅
- 应用“看到的连续”是**逻辑连续**；物理上**可以不连续** ✅

---

# 三道快问快答

1. 采用**索引分配**的文件在应用看来仍是连续字节流吗？
    
    → **是**（逻辑连续），OS负责把逻辑块映射到物理块。
    
2. 顺序文件用**链式存储**后，是否更省磁盘寻道？
    
    → **不一定**。链式只改变**逻辑组织**，物理是否邻近取决于**物理分配策略**。
    
3. 有了“索引文件（逻辑）”，还能再叠“索引分配（物理）”吗？
    
    → **能**。一个是**查记录**，一个是**查块**，互不冲突、经常同在。
    

---

![image.png](assets/image%2041.png)

## 文件存儲空間管理

# 1. 基础概念先卡牢

![image.png](assets/image%2042.png)

- **文件卷/逻辑卷**（C/D/E盘）：一个或多个**物理磁盘**组成的逻辑存储单位。
- **目录区 vs 文件区**：
    - 目录区：放目录项/FCB、inode，以及**空闲空间管理结构**（空闲表/链、位示图、超级块等）。
    - 文件区：放普通文件数据块。

# 2. 四种空闲空间管理方法（大纲式记忆）

## 2.1 空闲表法（Free Table）

**记录方式**：空闲区间表项 = ⟨起始盘块号，空闲块数⟩（类似“内存动态分区”的空闲表）。

![image.png](assets/image%2043.png)

**分配**：一次要连续块；在表上按**首次/最佳/最坏适应**选一段，摘出所需块并**改表项**（首址或长度）。

**回收**：与左右相邻空闲区**四种关系**：

1. 前后都不相邻 → 新增一表项；
2. 前后都相邻 → 三段合并，**表项数–1**；
3. 仅与前相邻 / 仅与后相邻 → 相应扩展该表项。
    
    **适用**：连续分配场景多；优点是顺读快；缺点是**外碎片**、维护表项开销。
    

## 2.2 空闲链表法（Free List）

两型要分清：

![image.png](assets/image%2044.png)

- **空闲盘块链**：以**单个盘块**为结点，结点里放“下一个空闲块”的指针。
    - 分配：从**链头**起，摘 K 个块；
    - 回收：回收到**链尾**；
    - 适用：离散分配，分多块要多次摘，效率偏低。
- **空闲盘区链**：以**连续盘区**为结点（结点首块记录“本盘区长度 + 下个盘区指针”）。
    - 分配：可配合首次/最佳/最坏适应；一把摘下一大片；也可多盘区拼接满足 K；
    - 回收：与邻接盘区**合并**，否则挂链尾；
    - 适用：连续/离散都可，给多块时比“盘块链”高效。

## 2.3 位示图法（Bitmap / 位视图）

**记录方式**：每个盘块对应一位（0/1 代表空闲/占用—**注意题目约定**）。按字节/字（如 16 位）连续存储。

![image.png](assets/image%2045.png)

**核心公式（超高频）**（设**字长 N**；“盘块号、字号、位号”是否从 0 还是从 1 开始以题面为准）：

- **0 起始**：
    - 盘块号 `b = N*i + j`；
    - 反推：`i = b // N`，`j = b % N`。
- **1 起始**：
    - 盘块号 `b = N*(i-1) + j`；
    - 反推：`i = floor((b-1)/N) + 1`，`j = ((b-1) % N) + 1`。

**分配**：顺扫位示图找 K 个 0（要求连续就找连续 K 个）；把相应位**置 1**并算出盘块号。

**回收**：由盘块号算出（i, j），将该位**置 0**。

**优缺点**：空间紧凑、定位快、支持大盘；大文件系统常用。

> 迷你练习（0 起始，N=16）
> 
> 
> Q1：`(i=1, j=10)` 对应盘块？A：`16*1+10=26`。
> 
> Q2：盘块 `31` 对 `(i,j)`？A：`i=31//16=1`，`j=31%16=15`。
> 

## 2.4 成组链接法（UNIX 经典）

**思路**：把空闲块**分组**管理，内存中的**超级块**（Superblock）保存“**下一组**空闲块数量 `n` + 这 `n` 个块号列表”。每组的**首块**再存**下一组**的（n, 列表）……形成“组链”。

![image.png](assets/image%2046.png)

- **分配 1 块**：
    - 若 `n>0`，弹出列表末尾一个块号；`n--`；
    - 若 `n==0`，从当前组首块**读入**下一组的（n, 列表）作为新的超级块内容，再弹出。
- **分配一整组（如要 100 块）**：
    - 逐个弹出；将**当前组首块**里保存的“下一组信息”**拷到超级块**，再继续（确保链不断）。
- **回收 1 块**：
    - 若 `n < 上限G`（如 100），把回收块号**压入超级块列表**，`n++`；
    - 否则（组已满）：把**当前超级块内容写入该回收块**（使其成为**新组首块**），然后把超级块重置为“只有这一个块”（`n=1, list=[该块]`）。
        
        **特点**：适合**超大文件系统**，一次 I/O 可搬运成组信息，分配/回收少寻道；实现略绕但**考法固定**（“分配/回收时超级块与组首块如何搬移信息”）。
        

# 3. 连续 & 离散分配与方法选择

- **连续分配优先**：空闲表、空闲盘区链、位示图（找连续 0 串）。顺序读快，但有**外碎片**、扩展难。
- **离散分配友好**：空闲盘块链、位示图、成组链接法。易扩展，随机性强，定位靠索引/链。

# 4. 考试常规问法与秒解模板

1. **给定位示图（字长 N），盘块号 ↔ (字号, 位号)**
    - 先判**起始基数**（0/1）；代入上面**两套公式**别混。
    - 别忘了题目定义的**0/1 语义**。
2. **空闲表法回收合并**
    - 画四种邻接情况，**谁合并、表项增减**一眼出。
3. **空闲链表法效率比较**
    - 盘块链：摘 K 次；盘区链：一次大段更优。
4. **成组链接法过程题**
    - **分配**：`n>0` 弹；`n==0` 先“**以组首块刷新超级块**”，再弹。
    - **回收**：`n<G` 直接推入；`n==G` 把**超级块抄写进回收块**，该块成新组首，超级块仅指它。

# 5. 易错点速查

- 位示图**从 0 还是 1 开始**？0/1 各代表什么？（常被反着用）
- 把**“逻辑链式记录”**和**“物理链接分配”**混为一谈（两个维度）。
- 空闲表回收忘了**双向邻接合并**导致表项数错。
- 成组链接法分配大批块时，**没把下一组信息移入超级块**就直接分配组首块，导致链断。

---

## 文件基本操作

---

# 1) 创建文件（create）

**参数**：路径、文件名、初始大小/所需盘块数（或属性）。

**内核流程**

1. **分配外存空间**：按所用空闲管理法（位示图/空闲表/空闲链/成组链接）找块并标占用。
2. **建目录项**：在目标目录的目录表里插入新目录项（含文件名、起始块/索引节点、长度、时间戳、权限等）。
3. 返回成功/失败。

**易错点**：创建≠打开；create 结束后**不一定已在“打开文件表”**中，很多系统是 create 成功后再 open。

---

# 2) 删除文件（delete）

**参数**：路径、文件名。

**内核流程**

1. 查目录→找到目录项，得到占用块位置/数量。
2. **回收外存块**：按空闲管理法释放。
3. **删目录项**。
    
    4.（若系统维护回收站/引用计数，遵循其策略）
    

**易错点**：很多操作系统**不允许删除“正被进程打开”的文件**（Windows 常见；题目爱考“先查系统打开文件表再决定能否删”）。

---

# 3) 打开文件（open）

![image.png](assets/image%2047.png)

**参数**：路径、文件名、打开方式/访问权限（只读、读写、追加等）。

**内核流程（两级表）**

1. 查目录→找到目录项，**检查权限**是否匹配所请求的访问方式。
2. **系统打开文件表（System OFT）**：若该文件尚未在表中，创建/填充一条表项；若已在，命中该表项并**打开计数器+1**。
3. **进程打开文件表（Per-Process OFT）**：为当前进程新增一条，记录：
    - 指向**系统表**的索引/指针
    - **读/写指针（文件偏移）**
    - 本次打开的**访问权限**
    
    ![image.png](assets/image%2048.png)
    
4. 返回**文件描述符/句柄**（即进程打开文件表中的索引号）。

**牢记**

- **打开并不会把文件数据读入内存**，只是把**目录项/必要元数据**搬到内存表中以便快速访问。
- 两张表的分工（本课程口径）：
    - **系统打开文件表**：全局唯一，含“**打开计数器**”等全局信息；
    - **进程打开文件表**：每进程一份，含“**读写指针**”“**访问权限**”，并指向系统表项。

---

# 4) 关闭文件（close）

**参数**：文件描述符。

**内核流程**

1. **删除进程打开文件表**中对应表项，释放该进程的缓存/缓冲区等资源。
2. **系统打开文件表**对应表项**计数–1**；若减到 0：
    - 必要时**写回脏数据/元数据**
    - 从系统表中移除该项。

**易错点**：不是“立刻写盘”，是否写回与缓存策略/脏位相关；但考试常以“计数为 0 → 可清理系统表项/刷新必要数据”为准。

---

# 5) 读文件（read）

**参数**：文件描述符、用户缓冲区地址、读入字节数。

**内核流程**

1. 在**进程打开文件表**取到**读指针（文件偏移）**与访问权限；检查是否允许读。
2. 依据目录项/索引信息将**逻辑偏移 → 物理块**，从外存（或页/缓冲缓存）读 **count** 字节到用户缓冲区。
3. **更新读指针** = 旧偏移 + 实际读入字节数。

**易错点**

- read 不需要再次给“文件名/路径”，只用**文件描述符**。
- 多进程可各自有独立读写指针（在“进程打开文件表”里）。

---

# 6) 写文件（write）

**参数**：文件描述符、用户缓冲区地址、写出字节数。

**内核流程**

1. 查“进程打开文件表”中的**写权限**与**写指针**。
2. 从用户缓冲区取数据，按需要**定位/分配新块**（文件增长时），写入外存并更新长度/时间戳。
3. **更新写指针**。必要时标记脏、触发回写或延迟写。

**易错点**：考试常问“哪个操作会真正分配外存块？”——**写**（以及创建时的初始化分配）；读不会。

---

## 速记表：谁放在哪张表？

| 信息项 | 系统打开文件表 | 进程打开文件表 |
| --- | --- | --- |
| 指向目录项/索引信息的引用 | ✔ | （通过指针间接） |
| **打开计数器** | ✔ |  |
| **访问权限（本次打开）** |  | ✔ |
| **读/写指针（文件偏移）** |  | ✔ |
| 文件描述符/句柄 |  | ✔（表索引号） |

---

## 高频考点·对号入座

- **Open vs Read**：Open 只建表项不读数据；Read 才把数据读入用户缓冲。
- **为什么要“系统+进程”两张表**：便于**共享文件**与**统一管理**（可检查是否被占用、实现“正在被使用→禁止删除”逻辑等）。
- **删除流程顺序**：先回收外存块，后删目录项（并考虑是否在系统打开文件表中被占用）。
- **写与分配**：写可能触发**块分配/扩展**，并更新文件大小与时间戳。
- **文件描述符** = 进程打开文件表索引（王道题面常出现这个术语）。

---

## 文件共享

---

# 核心概念

- **共享 ≠ 复制**
    
    共享：系统里**只有一份数据**，任何一方修改，**所有共享者可见**。
    
    复制：系统里有**多份数据副本**，互不影响。
    

---

# 硬链接（基于索引节点的共享）

![image.png](assets/image%2049.png)

- **做法**：不同用户/目录下的**目录项**都**指向同一个索引节点（inode）**。
- **联想图**：多条“文件名 → inode”的箭头，inode 内含：物理地址、属性、以及**链接计数 count**。
- **删除语义（必考）**：
    
    删除某个硬链接 ⇒ **仅删该目录项**、`count–1`；**只有当 `count==0`** 时，才真正删除**数据块 + inode**。
    
- **名字无关性**：各目录下的**文件名可以不同**（仍共享同一数据）。
- **优缺点**：
    - ✅ 访问直接命中 inode，**无额外目录级联开销**，访问快；
    - ✅ 任何一端修改，大家都能看到；
    - ❗删除时一定记住 **count 机制**。

---

# 软链接（基于符号链/快捷方式的共享）

![image.png](assets/image%2050.png)

![image.png](assets/image%2051.png)

- **做法**：建立一个**link 类型的特殊文件**（就像 Windows 的“快捷方式”），**文件内容保存“目标文件的路径”**。
- **访问流程**：先识别“link 类型”→ 按**路径**逐级查目录 → 找到目标文件后再访问。
- **删除/失效**：
    
    目标文件被删（其目录项不存在）→ **软链接仍然存在**，但**路径解析失败**（“悬空/失效链接”）。
    
- **性能特征**：每次都要按路径**逐级查目录**，存在**额外 I/O**，**比硬链接慢**。

---

# 硬 vs 软：速查表

| 维度 | 硬链接（硬连接） | 软链接（符号链接/快捷方式） |
| --- | --- | --- |
| 指向对象 | **inode（索引节点）** | **路径字符串** |
| 数据是否唯一 | 唯一一份数据，共享可见 | 仍是同一份数据，但靠路径找 |
| 删除目标后的行为 | `count–1`，仅 `count==0` 才真正删除数据 | 软链文件还在，但**路径找不到** → 失效 |
| 访问开销 | 直接命中 inode，**快** | 逐级解析路径，**慢** |
| 文件名 | **可不同名**，都指向同一 inode | 软链名通常自取，内容存路径 |

---

# 高频考点 & 口訣

- 共享≠复制：**是否“只有一份数据”**是分水岭。
- **硬链删不等于真删**：记住**`count==0` 才真正删除**。
- **软链易失效**：目标被删/路径变化 → **解析失败**。
- **速度**：硬链快，软链慢（因路径解析）。

---

# 迷你流程（硬链接删除）

1. 删目录项 → 2) 目标 inode 的 **count–1** →
2. 若 `count>0`：数据与 inode 均**保留**；
3. 若 `count==0`：**释放数据块与 inode**。

## 文件保護

---

# 三种文件保护方式

## 1) 口令保护（Password）

- **怎么做**：在文件的 FCB / 索引结点里**存口令**；访问时用户输入口令，系统比对。
- **优点**：实现与验证开销小（本来就要读 FCB/inode）。
- **缺点（易考）**：口令**存系统里** → 一旦泄露/被入侵就失效；只能“有/无访问”，**粒度粗**。

## 2) 加密保护（Encryption）

![image.png](assets/image%2052.png)

- **怎么做**：文件内容按某密钥**加密存放**；访问时用**同一密钥**解密后使用。
    - 课堂示例：**异或加密**（`C = P ⊕ K`，解密 `P = C ⊕ K`，性质：`x ⊕ k ⊕ k = x`）。
- **优点**：**保密性强**；**系统不必保存密钥**（用户自持/共享给被授权者即可）。
- **缺点**：有**编码/译码时间开销**；密钥管理麻烦（丢失密钥=数据不可读）。

## 3) 访问控制（Access Control）

![image.png](assets/image%2053.png)

- **怎么做**：在文件的 FCB / 索引结点里放**访问控制表（ACL）**：为用户/组记录其**可进行的操作**（读/写/执行/添加/删除/列目录…）。
- **两种粒度**：
    - **完整 ACL**：逐用户列权限（用户很多时表会很长）。
    - **精简 ACL**：按**组**赋权（如：管理员/文件主/文件主伙伴/其他用户）。
- **判定规则（Windows 示例）**：
    - **拒绝（Deny）优先于允许（Allow）**（考点！）
    - 用户可从**多组**继承权限；最终按合并后再应用“Deny 优先”。
    - **目录的权限会影响其下文件**（常见继承；考试口径：对目录限制 ⇒ 目录内文件也受限）。
- **优点**：**最灵活**，能区分多种操作类型与不同主体。
- **注意**：与口令/加密不同，ACL 并不要求知道“口令/密钥”，而是看**是否被授权该操作**。

---

# 三者对比速记

| 维度 | 口令保护 | 加密保护 | 访问控制（ACL） |
| --- | --- | --- | --- |
| 系统是否保存秘密 | **是**（口令在 FCB/inode） | **否**（密钥由用户掌握） | 否（保存**权限表**） |
| 安全性 | 低（口令泄露则失效） | 高（无密钥无法读懂数据） | 高（细粒度、可组合） |
| 性能开销 | 很小 | **加/解密开销** | 查询 ACL 开销小 |
| 粒度 | 粗（知口令=几乎全权） | 粗（知密钥=可读解） | **细**（按操作类型/主体控制） |
| 易错点 | 口令存系统、被入侵即破 | 必须同密钥；密钥管理 | **Deny 优先；目录权限影响子项** |

---

# 必背小结

- **口令 vs 加密**：一个“系统存口令比对”，一个“数据加密、系统可不存密钥”。
- **异或加密核心式**：`x ⊕ k ⊕ k = x`（同钥加解才能复原）。
- **ACL 判定**：看主体（用户/组）→ 合并权限 → **Deny 优先**。
- **目录权限**：限制目录 ⇒ 目录下文件通常也被限制（继承）。

---

# 迷你练习（自测 5 题）

1. 某文件设置口令；入侵者拿到磁盘镜像与系统口令区，即可读文件吗？
    
    **答**：可。口令在系统内，验证被绕过/获取后即可访问（安全性低）。
    
2. 用错密钥解密得到的内容与原文关系？
    
    **答**：与原文无关的“乱码”（例如异或：错误密钥不会还原）。
    
3. 只想让“文件主的伙伴组”**只读**，其他用户不可见，用哪种？
    
    **答**：**访问控制（精简 ACL）**，对伙伴组给读权限，对其他用户拒绝。
    
4. Windows 中对用户 A 显式勾选“拒绝读取”，但其所在组允许读取，结果？
    
    **答**：**拒绝生效**（Deny 优先于 Allow）。
    
5. 目录被拒绝访问，但你知道其中某文件的完整路径，能直接打开文件吗？
    
    **答**：通常**不行**（目录权限限制会阻止遍历/访问其中文件）。
    

## 虛擬文件系統

---

# 一、VFS 是啥？为啥要有？

![image.png](assets/image%2054.png)

- **问题**：同一台机子上可能同时存在多种文件系统（UFS/EXT、NTFS、FAT…），它们对 `open/read/write…` 的接口各不相同，应用就很麻烦。
- **VFS 作用（双向统一）**
    1. **向上统一**：对用户/应用只暴露一套**标准接口**（如 POSIX 的 `open/read/write/close`）。
    2. **向下约束**：要求具体文件系统**实现一组规定好的回调函数**（操作集/方法表）。没实现→不被支持。

> 记忆：VFS=“上收口、下约束”。
> 

---

# 二、V 节点 vnode（重点！）

![image.png](assets/image%2055.png)

> 讲义里把它念成 “V 节点 / vnode”（不是 Windows 😄）
> 
- **何时产生**：每当有文件被 `open`，VFS 在**内存**里为它建一个 **vnode**（V 节点）。
- **vnode 里有什么**：
    - 该文件的**统一格式元信息**（VFS视角）；
    - 一个**函数表指针**（**operations vector**）：指向该文件**所属具体文件系统**的 `open/read/write/...` 实现。
- **vnode vs inode（高频易混）**
    - **inode（索引节点）**：文件系统**自身**的元数据结构，**外存**有持久化，必要时会**读入内存**。
    - **vnode**：VFS 的**内存抽象**，**只存在内存**；可从 inode/目录项等信息**填充**出来；再靠函数表指针把操作**派发**到对应文件系统的真实实现。

> 考点结论：vnode 仅内存存在；inode 内外存都可能有。vnode 里有函数指针表，用于“调用下层真实FS实现”。
> 

---

# 三、一次 `open/read` 的典型路径

1. **路径解析**：VFS 逐级查目录（常配合**目录缓存**）。
2. 找到目标目录项/元信息 → 若需要把**inode**读入；
3. **构造 vnode**（统一视图）并挂上**操作表指针**；
4. 填写 **系统打开文件表**（全局，含打开计数）；
5. 在**进程打开文件表**建条目（记录**访问模式、读写指针**，以及指向系统表的索引）；返回 **fd**；
6. `read(fd)`：fd→进程表→系统表→vnode→（通过函数表）调到具体FS的 `read`，完成**逻辑→物理**映射与I/O。

> 记忆：fd 找进程表 → 找系统表 → 找 vnode → 函数表派发到具体FS。
> 

---

# 四、文件系统的挂载（mount）

让一个新文件系统**接入**到 VFS 的路径树中。

**步骤/要点：**

1. **注册**：VFS 的**挂载表**新增一个条目，登记该 FS 的**类型、容量/参数**等。
2. **提供操作表**：该 FS 把自己实现的 `open/read/write/...` 的**函数地址表**交给 VFS（否则无法被调度）。
3. **选择挂载点**：把该 FS **挂到某个目录**之下（mount point）。
    - **Windows**：以**盘符**形式出现（如 E:）。
    - **macOS/Linux**：挂在某个目录（如 `/Volumes/U盘`、`/mnt/usb`）。
4. （可选）卸载 `umount`：检查无进程占用、写回缓存、从挂载表移除、解绑挂载点。

> 关键词：挂载表、操作表、挂载点三件套。
> 

---

# 五、选择题“秒杀点”

- VFS **向上统一接口、向下要求实现接口**——对。
- **vnode 仅内存**；**inode 可在外存且可读入内存**——对。
- vnode 内含**函数功能指针表**，用来跳到具体 FS 的实现——对。
- `open` 会把**文件数据**读入内存吗？——**不会**（只是建表项/构建vnode）；真正 I/O 在 `read/write`。
- 挂载一定等于新分区？——不一定；**同一物理分区内可有多个FS**，也可**把任意支持的FS**挂到树上任意目录。

---